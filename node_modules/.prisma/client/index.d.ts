
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model player
 * 
 */
export type player = {
  id: number
  name: string
  numberJersey: string
  position: string
  status: Status
  team_id: number
}

/**
 * Model team
 * 
 */
export type team = {
  id: number
  name: string
  logo: string
}

/**
 * Model match
 * 
 */
export type match = {
  id: number
  homeTeam: number
  awayTeam: number
}

/**
 * Model offset
 * 
 */
export type offset = {
  id: number
  match_id: number
  offset_team_id: number
  offset_time: number
}

/**
 * Model goal
 * 
 */
export type goal = {
  id: number
  match_id: number
  player_id: number
  goal_time: number
}

/**
 * Model foul
 * 
 */
export type foul = {
  id: number
  match_id: number
  team_id: number
  player_id: number
  type: string | null
}

/**
 * Model injury
 * 
 */
export type injury = {
  id: number
  match_id: number
  player_id: number
  injury_type: string
}

/**
 * Model ballPossession
 * 
 */
export type ballPossession = {
  id: number
  match_id: number
  team_id: number
  possession_time: number
}

/**
 * Model card
 * 
 */
export type card = {
  id: number
  match_id: number
  player_id: number
  card_type: string
  card_time: number
}

/**
 * Model switchPlayer
 * 
 */
export type switchPlayer = {
  id: number
  match_id: number
  player_out_id: number
  player_in_id: number
  switch_time: number
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const Status: {
  main: 'main',
  cadangan: 'cadangan'
};

export type Status = (typeof Status)[keyof typeof Status]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Players
 * const players = await prisma.player.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Players
   * const players = await prisma.player.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.player`: Exposes CRUD operations for the **player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.playerDelegate<GlobalReject>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<GlobalReject>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.matchDelegate<GlobalReject>;

  /**
   * `prisma.offset`: Exposes CRUD operations for the **offset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offsets
    * const offsets = await prisma.offset.findMany()
    * ```
    */
  get offset(): Prisma.offsetDelegate<GlobalReject>;

  /**
   * `prisma.goal`: Exposes CRUD operations for the **goal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Goals
    * const goals = await prisma.goal.findMany()
    * ```
    */
  get goal(): Prisma.goalDelegate<GlobalReject>;

  /**
   * `prisma.foul`: Exposes CRUD operations for the **foul** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fouls
    * const fouls = await prisma.foul.findMany()
    * ```
    */
  get foul(): Prisma.foulDelegate<GlobalReject>;

  /**
   * `prisma.injury`: Exposes CRUD operations for the **injury** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Injuries
    * const injuries = await prisma.injury.findMany()
    * ```
    */
  get injury(): Prisma.injuryDelegate<GlobalReject>;

  /**
   * `prisma.ballPossession`: Exposes CRUD operations for the **ballPossession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BallPossessions
    * const ballPossessions = await prisma.ballPossession.findMany()
    * ```
    */
  get ballPossession(): Prisma.ballPossessionDelegate<GlobalReject>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.cardDelegate<GlobalReject>;

  /**
   * `prisma.switchPlayer`: Exposes CRUD operations for the **switchPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SwitchPlayers
    * const switchPlayers = await prisma.switchPlayer.findMany()
    * ```
    */
  get switchPlayer(): Prisma.switchPlayerDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    player: 'player',
    team: 'team',
    match: 'match',
    offset: 'offset',
    goal: 'goal',
    foul: 'foul',
    injury: 'injury',
    ballPossession: 'ballPossession',
    card: 'card',
    switchPlayer: 'switchPlayer'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlayerCountOutputType
   */


  export type PlayerCountOutputType = {
    goals: number
    injurys: number
    fouls: number
    cards: number
    switchPlayerOut: number
    switchPlayerIn: number
  }

  export type PlayerCountOutputTypeSelect = {
    goals?: boolean
    injurys?: boolean
    fouls?: boolean
    cards?: boolean
    switchPlayerOut?: boolean
    switchPlayerIn?: boolean
  }

  export type PlayerCountOutputTypeGetPayload<S extends boolean | null | undefined | PlayerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PlayerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PlayerCountOutputTypeArgs)
    ? PlayerCountOutputType 
    : S extends { select: any } & (PlayerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PlayerCountOutputType ? PlayerCountOutputType[P] : never
  } 
      : PlayerCountOutputType




  // Custom InputTypes

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect | null
  }



  /**
   * Count Type TeamCountOutputType
   */


  export type TeamCountOutputType = {
    match1: number
    match2: number
    player: number
    offset: number
    ballPossession: number
  }

  export type TeamCountOutputTypeSelect = {
    match1?: boolean
    match2?: boolean
    player?: boolean
    offset?: boolean
    ballPossession?: boolean
  }

  export type TeamCountOutputTypeGetPayload<S extends boolean | null | undefined | TeamCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TeamCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TeamCountOutputTypeArgs)
    ? TeamCountOutputType 
    : S extends { select: any } & (TeamCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TeamCountOutputType ? TeamCountOutputType[P] : never
  } 
      : TeamCountOutputType




  // Custom InputTypes

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect | null
  }



  /**
   * Count Type MatchCountOutputType
   */


  export type MatchCountOutputType = {
    offset: number
    goal: number
    foul: number
    injury: number
    ballPossession: number
    card: number
    switchPlayer: number
  }

  export type MatchCountOutputTypeSelect = {
    offset?: boolean
    goal?: boolean
    foul?: boolean
    injury?: boolean
    ballPossession?: boolean
    card?: boolean
    switchPlayer?: boolean
  }

  export type MatchCountOutputTypeGetPayload<S extends boolean | null | undefined | MatchCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MatchCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MatchCountOutputTypeArgs)
    ? MatchCountOutputType 
    : S extends { select: any } & (MatchCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MatchCountOutputType ? MatchCountOutputType[P] : never
  } 
      : MatchCountOutputType




  // Custom InputTypes

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model player
   */


  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    id: number | null
    team_id: number | null
  }

  export type PlayerSumAggregateOutputType = {
    id: number | null
    team_id: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: number | null
    name: string | null
    numberJersey: string | null
    position: string | null
    status: Status | null
    team_id: number | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    numberJersey: string | null
    position: string | null
    status: Status | null
    team_id: number | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    name: number
    numberJersey: number
    position: number
    status: number
    team_id: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    id?: true
    team_id?: true
  }

  export type PlayerSumAggregateInputType = {
    id?: true
    team_id?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    name?: true
    numberJersey?: true
    position?: true
    status?: true
    team_id?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    name?: true
    numberJersey?: true
    position?: true
    status?: true
    team_id?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    name?: true
    numberJersey?: true
    position?: true
    status?: true
    team_id?: true
    _all?: true
  }

  export type PlayerAggregateArgs = {
    /**
     * Filter which player to aggregate.
     */
    where?: playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players to fetch.
     */
    orderBy?: Enumerable<playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs = {
    where?: playerWhereInput
    orderBy?: Enumerable<playerOrderByWithAggregationInput>
    by: PlayerScalarFieldEnum[]
    having?: playerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }


  export type PlayerGroupByOutputType = {
    id: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type playerSelect = {
    id?: boolean
    name?: boolean
    numberJersey?: boolean
    position?: boolean
    status?: boolean
    team_id?: boolean
    goals?: boolean | player$goalsArgs
    injurys?: boolean | player$injurysArgs
    fouls?: boolean | player$foulsArgs
    cards?: boolean | player$cardsArgs
    team?: boolean | teamArgs
    switchPlayerOut?: boolean | player$switchPlayerOutArgs
    switchPlayerIn?: boolean | player$switchPlayerInArgs
    _count?: boolean | PlayerCountOutputTypeArgs
  }


  export type playerInclude = {
    goals?: boolean | player$goalsArgs
    injurys?: boolean | player$injurysArgs
    fouls?: boolean | player$foulsArgs
    cards?: boolean | player$cardsArgs
    team?: boolean | teamArgs
    switchPlayerOut?: boolean | player$switchPlayerOutArgs
    switchPlayerIn?: boolean | player$switchPlayerInArgs
    _count?: boolean | PlayerCountOutputTypeArgs
  }

  export type playerGetPayload<S extends boolean | null | undefined | playerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? player :
    S extends undefined ? never :
    S extends { include: any } & (playerArgs | playerFindManyArgs)
    ? player  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'goals' ? Array < goalGetPayload<S['include'][P]>>  :
        P extends 'injurys' ? Array < injuryGetPayload<S['include'][P]>>  :
        P extends 'fouls' ? Array < foulGetPayload<S['include'][P]>>  :
        P extends 'cards' ? Array < cardGetPayload<S['include'][P]>>  :
        P extends 'team' ? teamGetPayload<S['include'][P]> :
        P extends 'switchPlayerOut' ? Array < switchPlayerGetPayload<S['include'][P]>>  :
        P extends 'switchPlayerIn' ? Array < switchPlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? PlayerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (playerArgs | playerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'goals' ? Array < goalGetPayload<S['select'][P]>>  :
        P extends 'injurys' ? Array < injuryGetPayload<S['select'][P]>>  :
        P extends 'fouls' ? Array < foulGetPayload<S['select'][P]>>  :
        P extends 'cards' ? Array < cardGetPayload<S['select'][P]>>  :
        P extends 'team' ? teamGetPayload<S['select'][P]> :
        P extends 'switchPlayerOut' ? Array < switchPlayerGetPayload<S['select'][P]>>  :
        P extends 'switchPlayerIn' ? Array < switchPlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? PlayerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof player ? player[P] : never
  } 
      : player


  type playerCountArgs = 
    Omit<playerFindManyArgs, 'select' | 'include'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface playerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Player that matches the filter.
     * @param {playerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends playerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, playerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'player'> extends True ? Prisma__playerClient<playerGetPayload<T>> : Prisma__playerClient<playerGetPayload<T> | null, null>

    /**
     * Find one Player that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {playerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends playerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, playerFindUniqueOrThrowArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {playerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends playerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, playerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'player'> extends True ? Prisma__playerClient<playerGetPayload<T>> : Prisma__playerClient<playerGetPayload<T> | null, null>

    /**
     * Find the first Player that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {playerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends playerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, playerFindFirstOrThrowArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {playerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends playerFindManyArgs>(
      args?: SelectSubset<T, playerFindManyArgs>
    ): Prisma.PrismaPromise<Array<playerGetPayload<T>>>

    /**
     * Create a Player.
     * @param {playerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
    **/
    create<T extends playerCreateArgs>(
      args: SelectSubset<T, playerCreateArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Create many Players.
     *     @param {playerCreateManyArgs} args - Arguments to create many Players.
     *     @example
     *     // Create many Players
     *     const player = await prisma.player.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends playerCreateManyArgs>(
      args?: SelectSubset<T, playerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Player.
     * @param {playerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
    **/
    delete<T extends playerDeleteArgs>(
      args: SelectSubset<T, playerDeleteArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Update one Player.
     * @param {playerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends playerUpdateArgs>(
      args: SelectSubset<T, playerUpdateArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Delete zero or more Players.
     * @param {playerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends playerDeleteManyArgs>(
      args?: SelectSubset<T, playerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {playerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends playerUpdateManyArgs>(
      args: SelectSubset<T, playerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {playerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
    **/
    upsert<T extends playerUpsertArgs>(
      args: SelectSubset<T, playerUpsertArgs>
    ): Prisma__playerClient<playerGetPayload<T>>

    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {playerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends playerCountArgs>(
      args?: Subset<T, playerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__playerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    goals<T extends player$goalsArgs= {}>(args?: Subset<T, player$goalsArgs>): Prisma.PrismaPromise<Array<goalGetPayload<T>>| Null>;

    injurys<T extends player$injurysArgs= {}>(args?: Subset<T, player$injurysArgs>): Prisma.PrismaPromise<Array<injuryGetPayload<T>>| Null>;

    fouls<T extends player$foulsArgs= {}>(args?: Subset<T, player$foulsArgs>): Prisma.PrismaPromise<Array<foulGetPayload<T>>| Null>;

    cards<T extends player$cardsArgs= {}>(args?: Subset<T, player$cardsArgs>): Prisma.PrismaPromise<Array<cardGetPayload<T>>| Null>;

    team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    switchPlayerOut<T extends player$switchPlayerOutArgs= {}>(args?: Subset<T, player$switchPlayerOutArgs>): Prisma.PrismaPromise<Array<switchPlayerGetPayload<T>>| Null>;

    switchPlayerIn<T extends player$switchPlayerInArgs= {}>(args?: Subset<T, player$switchPlayerInArgs>): Prisma.PrismaPromise<Array<switchPlayerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * player base type for findUnique actions
   */
  export type playerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter, which player to fetch.
     */
    where: playerWhereUniqueInput
  }

  /**
   * player findUnique
   */
  export interface playerFindUniqueArgs extends playerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player findUniqueOrThrow
   */
  export type playerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter, which player to fetch.
     */
    where: playerWhereUniqueInput
  }


  /**
   * player base type for findFirst actions
   */
  export type playerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter, which player to fetch.
     */
    where?: playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players to fetch.
     */
    orderBy?: Enumerable<playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for players.
     */
    cursor?: playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of players.
     */
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }

  /**
   * player findFirst
   */
  export interface playerFindFirstArgs extends playerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * player findFirstOrThrow
   */
  export type playerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter, which player to fetch.
     */
    where?: playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players to fetch.
     */
    orderBy?: Enumerable<playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for players.
     */
    cursor?: playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of players.
     */
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * player findMany
   */
  export type playerFindManyArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter, which players to fetch.
     */
    where?: playerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of players to fetch.
     */
    orderBy?: Enumerable<playerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing players.
     */
    cursor?: playerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` players.
     */
    skip?: number
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * player create
   */
  export type playerCreateArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * The data needed to create a player.
     */
    data: XOR<playerCreateInput, playerUncheckedCreateInput>
  }


  /**
   * player createMany
   */
  export type playerCreateManyArgs = {
    /**
     * The data used to create many players.
     */
    data: Enumerable<playerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * player update
   */
  export type playerUpdateArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * The data needed to update a player.
     */
    data: XOR<playerUpdateInput, playerUncheckedUpdateInput>
    /**
     * Choose, which player to update.
     */
    where: playerWhereUniqueInput
  }


  /**
   * player updateMany
   */
  export type playerUpdateManyArgs = {
    /**
     * The data used to update players.
     */
    data: XOR<playerUpdateManyMutationInput, playerUncheckedUpdateManyInput>
    /**
     * Filter which players to update
     */
    where?: playerWhereInput
  }


  /**
   * player upsert
   */
  export type playerUpsertArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * The filter to search for the player to update in case it exists.
     */
    where: playerWhereUniqueInput
    /**
     * In case the player found by the `where` argument doesn't exist, create a new player with this data.
     */
    create: XOR<playerCreateInput, playerUncheckedCreateInput>
    /**
     * In case the player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<playerUpdateInput, playerUncheckedUpdateInput>
  }


  /**
   * player delete
   */
  export type playerDeleteArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    /**
     * Filter which player to delete.
     */
    where: playerWhereUniqueInput
  }


  /**
   * player deleteMany
   */
  export type playerDeleteManyArgs = {
    /**
     * Filter which players to delete
     */
    where?: playerWhereInput
  }


  /**
   * player.goals
   */
  export type player$goalsArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    where?: goalWhereInput
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    cursor?: goalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GoalScalarFieldEnum>
  }


  /**
   * player.injurys
   */
  export type player$injurysArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    where?: injuryWhereInput
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    cursor?: injuryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InjuryScalarFieldEnum>
  }


  /**
   * player.fouls
   */
  export type player$foulsArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    where?: foulWhereInput
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    cursor?: foulWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FoulScalarFieldEnum>
  }


  /**
   * player.cards
   */
  export type player$cardsArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    where?: cardWhereInput
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    cursor?: cardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * player.switchPlayerOut
   */
  export type player$switchPlayerOutArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    where?: switchPlayerWhereInput
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    cursor?: switchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }


  /**
   * player.switchPlayerIn
   */
  export type player$switchPlayerInArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    where?: switchPlayerWhereInput
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    cursor?: switchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }


  /**
   * player without action
   */
  export type playerArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
  }



  /**
   * Model team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    logo: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    logo: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    logo: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    logo?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    logo?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    logo?: true
    _all?: true
  }

  export type TeamAggregateArgs = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs = {
    where?: teamWhereInput
    orderBy?: Enumerable<teamOrderByWithAggregationInput>
    by: TeamScalarFieldEnum[]
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: number
    name: string
    logo: string
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect = {
    id?: boolean
    name?: boolean
    logo?: boolean
    match1?: boolean | team$match1Args
    match2?: boolean | team$match2Args
    player?: boolean | team$playerArgs
    offset?: boolean | team$offsetArgs
    ballPossession?: boolean | team$ballPossessionArgs
    _count?: boolean | TeamCountOutputTypeArgs
  }


  export type teamInclude = {
    match1?: boolean | team$match1Args
    match2?: boolean | team$match2Args
    player?: boolean | team$playerArgs
    offset?: boolean | team$offsetArgs
    ballPossession?: boolean | team$ballPossessionArgs
    _count?: boolean | TeamCountOutputTypeArgs
  }

  export type teamGetPayload<S extends boolean | null | undefined | teamArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? team :
    S extends undefined ? never :
    S extends { include: any } & (teamArgs | teamFindManyArgs)
    ? team  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'match1' ? Array < matchGetPayload<S['include'][P]>>  :
        P extends 'match2' ? Array < matchGetPayload<S['include'][P]>>  :
        P extends 'player' ? Array < playerGetPayload<S['include'][P]>>  :
        P extends 'offset' ? Array < offsetGetPayload<S['include'][P]>>  :
        P extends 'ballPossession' ? Array < ballPossessionGetPayload<S['include'][P]>>  :
        P extends '_count' ? TeamCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (teamArgs | teamFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'match1' ? Array < matchGetPayload<S['select'][P]>>  :
        P extends 'match2' ? Array < matchGetPayload<S['select'][P]>>  :
        P extends 'player' ? Array < playerGetPayload<S['select'][P]>>  :
        P extends 'offset' ? Array < offsetGetPayload<S['select'][P]>>  :
        P extends 'ballPossession' ? Array < ballPossessionGetPayload<S['select'][P]>>  :
        P extends '_count' ? TeamCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof team ? team[P] : never
  } 
      : team


  type teamCountArgs = 
    Omit<teamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teamFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, teamFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'team'> extends True ? Prisma__teamClient<teamGetPayload<T>> : Prisma__teamClient<teamGetPayload<T> | null, null>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, teamFindUniqueOrThrowArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teamFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, teamFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'team'> extends True ? Prisma__teamClient<teamGetPayload<T>> : Prisma__teamClient<teamGetPayload<T> | null, null>

    /**
     * Find the first Team that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs>(
      args?: SelectSubset<T, teamFindFirstOrThrowArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends teamFindManyArgs>(
      args?: SelectSubset<T, teamFindManyArgs>
    ): Prisma.PrismaPromise<Array<teamGetPayload<T>>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends teamCreateArgs>(
      args: SelectSubset<T, teamCreateArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Create many Teams.
     *     @param {teamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teamCreateManyArgs>(
      args?: SelectSubset<T, teamCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends teamDeleteArgs>(
      args: SelectSubset<T, teamDeleteArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teamUpdateArgs>(
      args: SelectSubset<T, teamUpdateArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teamDeleteManyArgs>(
      args?: SelectSubset<T, teamDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teamUpdateManyArgs>(
      args: SelectSubset<T, teamUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends teamUpsertArgs>(
      args: SelectSubset<T, teamUpsertArgs>
    ): Prisma__teamClient<teamGetPayload<T>>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__teamClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    match1<T extends team$match1Args= {}>(args?: Subset<T, team$match1Args>): Prisma.PrismaPromise<Array<matchGetPayload<T>>| Null>;

    match2<T extends team$match2Args= {}>(args?: Subset<T, team$match2Args>): Prisma.PrismaPromise<Array<matchGetPayload<T>>| Null>;

    player<T extends team$playerArgs= {}>(args?: Subset<T, team$playerArgs>): Prisma.PrismaPromise<Array<playerGetPayload<T>>| Null>;

    offset<T extends team$offsetArgs= {}>(args?: Subset<T, team$offsetArgs>): Prisma.PrismaPromise<Array<offsetGetPayload<T>>| Null>;

    ballPossession<T extends team$ballPossessionArgs= {}>(args?: Subset<T, team$ballPossessionArgs>): Prisma.PrismaPromise<Array<ballPossessionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * team base type for findUnique actions
   */
  export type teamFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findUnique
   */
  export interface teamFindUniqueArgs extends teamFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team base type for findFirst actions
   */
  export type teamFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }

  /**
   * team findFirst
   */
  export interface teamFindFirstArgs extends teamFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * team findMany
   */
  export type teamFindManyArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: Enumerable<teamOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: Enumerable<TeamScalarFieldEnum>
  }


  /**
   * team create
   */
  export type teamCreateArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }


  /**
   * team createMany
   */
  export type teamCreateManyArgs = {
    /**
     * The data used to create many teams.
     */
    data: Enumerable<teamCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * team update
   */
  export type teamUpdateArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team updateMany
   */
  export type teamUpdateManyArgs = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }


  /**
   * team upsert
   */
  export type teamUpsertArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }


  /**
   * team delete
   */
  export type teamDeleteArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }


  /**
   * team.match1
   */
  export type team$match1Args = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    where?: matchWhereInput
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    cursor?: matchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MatchScalarFieldEnum>
  }


  /**
   * team.match2
   */
  export type team$match2Args = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    where?: matchWhereInput
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    cursor?: matchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MatchScalarFieldEnum>
  }


  /**
   * team.player
   */
  export type team$playerArgs = {
    /**
     * Select specific fields to fetch from the player
     */
    select?: playerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: playerInclude | null
    where?: playerWhereInput
    orderBy?: Enumerable<playerOrderByWithRelationInput>
    cursor?: playerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PlayerScalarFieldEnum>
  }


  /**
   * team.offset
   */
  export type team$offsetArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    where?: offsetWhereInput
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    cursor?: offsetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OffsetScalarFieldEnum>
  }


  /**
   * team.ballPossession
   */
  export type team$ballPossessionArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    where?: ballPossessionWhereInput
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    cursor?: ballPossessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BallPossessionScalarFieldEnum>
  }


  /**
   * team without action
   */
  export type teamArgs = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude | null
  }



  /**
   * Model match
   */


  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    id: number | null
    homeTeam: number | null
    awayTeam: number | null
  }

  export type MatchSumAggregateOutputType = {
    id: number | null
    homeTeam: number | null
    awayTeam: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: number | null
    homeTeam: number | null
    awayTeam: number | null
  }

  export type MatchMaxAggregateOutputType = {
    id: number | null
    homeTeam: number | null
    awayTeam: number | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    homeTeam: number
    awayTeam: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    id?: true
    homeTeam?: true
    awayTeam?: true
  }

  export type MatchSumAggregateInputType = {
    id?: true
    homeTeam?: true
    awayTeam?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    homeTeam?: true
    awayTeam?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    homeTeam?: true
    awayTeam?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    homeTeam?: true
    awayTeam?: true
    _all?: true
  }

  export type MatchAggregateArgs = {
    /**
     * Filter which match to aggregate.
     */
    where?: matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs = {
    where?: matchWhereInput
    orderBy?: Enumerable<matchOrderByWithAggregationInput>
    by: MatchScalarFieldEnum[]
    having?: matchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }


  export type MatchGroupByOutputType = {
    id: number
    homeTeam: number
    awayTeam: number
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type matchSelect = {
    id?: boolean
    homeTeam?: boolean
    awayTeam?: boolean
    home_team?: boolean | teamArgs
    away_team?: boolean | teamArgs
    offset?: boolean | match$offsetArgs
    goal?: boolean | match$goalArgs
    foul?: boolean | match$foulArgs
    injury?: boolean | match$injuryArgs
    ballPossession?: boolean | match$ballPossessionArgs
    card?: boolean | match$cardArgs
    switchPlayer?: boolean | match$switchPlayerArgs
    _count?: boolean | MatchCountOutputTypeArgs
  }


  export type matchInclude = {
    home_team?: boolean | teamArgs
    away_team?: boolean | teamArgs
    offset?: boolean | match$offsetArgs
    goal?: boolean | match$goalArgs
    foul?: boolean | match$foulArgs
    injury?: boolean | match$injuryArgs
    ballPossession?: boolean | match$ballPossessionArgs
    card?: boolean | match$cardArgs
    switchPlayer?: boolean | match$switchPlayerArgs
    _count?: boolean | MatchCountOutputTypeArgs
  }

  export type matchGetPayload<S extends boolean | null | undefined | matchArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? match :
    S extends undefined ? never :
    S extends { include: any } & (matchArgs | matchFindManyArgs)
    ? match  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'home_team' ? teamGetPayload<S['include'][P]> :
        P extends 'away_team' ? teamGetPayload<S['include'][P]> :
        P extends 'offset' ? Array < offsetGetPayload<S['include'][P]>>  :
        P extends 'goal' ? Array < goalGetPayload<S['include'][P]>>  :
        P extends 'foul' ? Array < foulGetPayload<S['include'][P]>>  :
        P extends 'injury' ? Array < injuryGetPayload<S['include'][P]>>  :
        P extends 'ballPossession' ? Array < ballPossessionGetPayload<S['include'][P]>>  :
        P extends 'card' ? Array < cardGetPayload<S['include'][P]>>  :
        P extends 'switchPlayer' ? Array < switchPlayerGetPayload<S['include'][P]>>  :
        P extends '_count' ? MatchCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (matchArgs | matchFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'home_team' ? teamGetPayload<S['select'][P]> :
        P extends 'away_team' ? teamGetPayload<S['select'][P]> :
        P extends 'offset' ? Array < offsetGetPayload<S['select'][P]>>  :
        P extends 'goal' ? Array < goalGetPayload<S['select'][P]>>  :
        P extends 'foul' ? Array < foulGetPayload<S['select'][P]>>  :
        P extends 'injury' ? Array < injuryGetPayload<S['select'][P]>>  :
        P extends 'ballPossession' ? Array < ballPossessionGetPayload<S['select'][P]>>  :
        P extends 'card' ? Array < cardGetPayload<S['select'][P]>>  :
        P extends 'switchPlayer' ? Array < switchPlayerGetPayload<S['select'][P]>>  :
        P extends '_count' ? MatchCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof match ? match[P] : never
  } 
      : match


  type matchCountArgs = 
    Omit<matchFindManyArgs, 'select' | 'include'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface matchDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Match that matches the filter.
     * @param {matchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends matchFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, matchFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'match'> extends True ? Prisma__matchClient<matchGetPayload<T>> : Prisma__matchClient<matchGetPayload<T> | null, null>

    /**
     * Find one Match that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {matchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends matchFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, matchFindUniqueOrThrowArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends matchFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, matchFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'match'> extends True ? Prisma__matchClient<matchGetPayload<T>> : Prisma__matchClient<matchGetPayload<T> | null, null>

    /**
     * Find the first Match that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends matchFindFirstOrThrowArgs>(
      args?: SelectSubset<T, matchFindFirstOrThrowArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends matchFindManyArgs>(
      args?: SelectSubset<T, matchFindManyArgs>
    ): Prisma.PrismaPromise<Array<matchGetPayload<T>>>

    /**
     * Create a Match.
     * @param {matchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
    **/
    create<T extends matchCreateArgs>(
      args: SelectSubset<T, matchCreateArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Create many Matches.
     *     @param {matchCreateManyArgs} args - Arguments to create many Matches.
     *     @example
     *     // Create many Matches
     *     const match = await prisma.match.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends matchCreateManyArgs>(
      args?: SelectSubset<T, matchCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Match.
     * @param {matchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
    **/
    delete<T extends matchDeleteArgs>(
      args: SelectSubset<T, matchDeleteArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Update one Match.
     * @param {matchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends matchUpdateArgs>(
      args: SelectSubset<T, matchUpdateArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Delete zero or more Matches.
     * @param {matchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends matchDeleteManyArgs>(
      args?: SelectSubset<T, matchDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends matchUpdateManyArgs>(
      args: SelectSubset<T, matchUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Match.
     * @param {matchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
    **/
    upsert<T extends matchUpsertArgs>(
      args: SelectSubset<T, matchUpsertArgs>
    ): Prisma__matchClient<matchGetPayload<T>>

    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {matchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends matchCountArgs>(
      args?: Subset<T, matchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__matchClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    home_team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    away_team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    offset<T extends match$offsetArgs= {}>(args?: Subset<T, match$offsetArgs>): Prisma.PrismaPromise<Array<offsetGetPayload<T>>| Null>;

    goal<T extends match$goalArgs= {}>(args?: Subset<T, match$goalArgs>): Prisma.PrismaPromise<Array<goalGetPayload<T>>| Null>;

    foul<T extends match$foulArgs= {}>(args?: Subset<T, match$foulArgs>): Prisma.PrismaPromise<Array<foulGetPayload<T>>| Null>;

    injury<T extends match$injuryArgs= {}>(args?: Subset<T, match$injuryArgs>): Prisma.PrismaPromise<Array<injuryGetPayload<T>>| Null>;

    ballPossession<T extends match$ballPossessionArgs= {}>(args?: Subset<T, match$ballPossessionArgs>): Prisma.PrismaPromise<Array<ballPossessionGetPayload<T>>| Null>;

    card<T extends match$cardArgs= {}>(args?: Subset<T, match$cardArgs>): Prisma.PrismaPromise<Array<cardGetPayload<T>>| Null>;

    switchPlayer<T extends match$switchPlayerArgs= {}>(args?: Subset<T, match$switchPlayerArgs>): Prisma.PrismaPromise<Array<switchPlayerGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * match base type for findUnique actions
   */
  export type matchFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter, which match to fetch.
     */
    where: matchWhereUniqueInput
  }

  /**
   * match findUnique
   */
  export interface matchFindUniqueArgs extends matchFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * match findUniqueOrThrow
   */
  export type matchFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter, which match to fetch.
     */
    where: matchWhereUniqueInput
  }


  /**
   * match base type for findFirst actions
   */
  export type matchFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter, which match to fetch.
     */
    where?: matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matches.
     */
    cursor?: matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matches.
     */
    distinct?: Enumerable<MatchScalarFieldEnum>
  }

  /**
   * match findFirst
   */
  export interface matchFindFirstArgs extends matchFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * match findFirstOrThrow
   */
  export type matchFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter, which match to fetch.
     */
    where?: matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for matches.
     */
    cursor?: matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of matches.
     */
    distinct?: Enumerable<MatchScalarFieldEnum>
  }


  /**
   * match findMany
   */
  export type matchFindManyArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter, which matches to fetch.
     */
    where?: matchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of matches to fetch.
     */
    orderBy?: Enumerable<matchOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing matches.
     */
    cursor?: matchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` matches.
     */
    skip?: number
    distinct?: Enumerable<MatchScalarFieldEnum>
  }


  /**
   * match create
   */
  export type matchCreateArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * The data needed to create a match.
     */
    data: XOR<matchCreateInput, matchUncheckedCreateInput>
  }


  /**
   * match createMany
   */
  export type matchCreateManyArgs = {
    /**
     * The data used to create many matches.
     */
    data: Enumerable<matchCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * match update
   */
  export type matchUpdateArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * The data needed to update a match.
     */
    data: XOR<matchUpdateInput, matchUncheckedUpdateInput>
    /**
     * Choose, which match to update.
     */
    where: matchWhereUniqueInput
  }


  /**
   * match updateMany
   */
  export type matchUpdateManyArgs = {
    /**
     * The data used to update matches.
     */
    data: XOR<matchUpdateManyMutationInput, matchUncheckedUpdateManyInput>
    /**
     * Filter which matches to update
     */
    where?: matchWhereInput
  }


  /**
   * match upsert
   */
  export type matchUpsertArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * The filter to search for the match to update in case it exists.
     */
    where: matchWhereUniqueInput
    /**
     * In case the match found by the `where` argument doesn't exist, create a new match with this data.
     */
    create: XOR<matchCreateInput, matchUncheckedCreateInput>
    /**
     * In case the match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<matchUpdateInput, matchUncheckedUpdateInput>
  }


  /**
   * match delete
   */
  export type matchDeleteArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
    /**
     * Filter which match to delete.
     */
    where: matchWhereUniqueInput
  }


  /**
   * match deleteMany
   */
  export type matchDeleteManyArgs = {
    /**
     * Filter which matches to delete
     */
    where?: matchWhereInput
  }


  /**
   * match.offset
   */
  export type match$offsetArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    where?: offsetWhereInput
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    cursor?: offsetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OffsetScalarFieldEnum>
  }


  /**
   * match.goal
   */
  export type match$goalArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    where?: goalWhereInput
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    cursor?: goalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<GoalScalarFieldEnum>
  }


  /**
   * match.foul
   */
  export type match$foulArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    where?: foulWhereInput
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    cursor?: foulWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FoulScalarFieldEnum>
  }


  /**
   * match.injury
   */
  export type match$injuryArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    where?: injuryWhereInput
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    cursor?: injuryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<InjuryScalarFieldEnum>
  }


  /**
   * match.ballPossession
   */
  export type match$ballPossessionArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    where?: ballPossessionWhereInput
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    cursor?: ballPossessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BallPossessionScalarFieldEnum>
  }


  /**
   * match.card
   */
  export type match$cardArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    where?: cardWhereInput
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    cursor?: cardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * match.switchPlayer
   */
  export type match$switchPlayerArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    where?: switchPlayerWhereInput
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    cursor?: switchPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }


  /**
   * match without action
   */
  export type matchArgs = {
    /**
     * Select specific fields to fetch from the match
     */
    select?: matchSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: matchInclude | null
  }



  /**
   * Model offset
   */


  export type AggregateOffset = {
    _count: OffsetCountAggregateOutputType | null
    _avg: OffsetAvgAggregateOutputType | null
    _sum: OffsetSumAggregateOutputType | null
    _min: OffsetMinAggregateOutputType | null
    _max: OffsetMaxAggregateOutputType | null
  }

  export type OffsetAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    offset_team_id: number | null
    offset_time: number | null
  }

  export type OffsetSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    offset_team_id: number | null
    offset_time: number | null
  }

  export type OffsetMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    offset_team_id: number | null
    offset_time: number | null
  }

  export type OffsetMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    offset_team_id: number | null
    offset_time: number | null
  }

  export type OffsetCountAggregateOutputType = {
    id: number
    match_id: number
    offset_team_id: number
    offset_time: number
    _all: number
  }


  export type OffsetAvgAggregateInputType = {
    id?: true
    match_id?: true
    offset_team_id?: true
    offset_time?: true
  }

  export type OffsetSumAggregateInputType = {
    id?: true
    match_id?: true
    offset_team_id?: true
    offset_time?: true
  }

  export type OffsetMinAggregateInputType = {
    id?: true
    match_id?: true
    offset_team_id?: true
    offset_time?: true
  }

  export type OffsetMaxAggregateInputType = {
    id?: true
    match_id?: true
    offset_team_id?: true
    offset_time?: true
  }

  export type OffsetCountAggregateInputType = {
    id?: true
    match_id?: true
    offset_team_id?: true
    offset_time?: true
    _all?: true
  }

  export type OffsetAggregateArgs = {
    /**
     * Filter which offset to aggregate.
     */
    where?: offsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offsets to fetch.
     */
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offsets
    **/
    _count?: true | OffsetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffsetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffsetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffsetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffsetMaxAggregateInputType
  }

  export type GetOffsetAggregateType<T extends OffsetAggregateArgs> = {
        [P in keyof T & keyof AggregateOffset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffset[P]>
      : GetScalarType<T[P], AggregateOffset[P]>
  }




  export type OffsetGroupByArgs = {
    where?: offsetWhereInput
    orderBy?: Enumerable<offsetOrderByWithAggregationInput>
    by: OffsetScalarFieldEnum[]
    having?: offsetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffsetCountAggregateInputType | true
    _avg?: OffsetAvgAggregateInputType
    _sum?: OffsetSumAggregateInputType
    _min?: OffsetMinAggregateInputType
    _max?: OffsetMaxAggregateInputType
  }


  export type OffsetGroupByOutputType = {
    id: number
    match_id: number
    offset_team_id: number
    offset_time: number
    _count: OffsetCountAggregateOutputType | null
    _avg: OffsetAvgAggregateOutputType | null
    _sum: OffsetSumAggregateOutputType | null
    _min: OffsetMinAggregateOutputType | null
    _max: OffsetMaxAggregateOutputType | null
  }

  type GetOffsetGroupByPayload<T extends OffsetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OffsetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffsetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffsetGroupByOutputType[P]>
            : GetScalarType<T[P], OffsetGroupByOutputType[P]>
        }
      >
    >


  export type offsetSelect = {
    id?: boolean
    match_id?: boolean
    offset_team_id?: boolean
    offset_time?: boolean
    match?: boolean | matchArgs
    offset_team?: boolean | teamArgs
  }


  export type offsetInclude = {
    match?: boolean | matchArgs
    offset_team?: boolean | teamArgs
  }

  export type offsetGetPayload<S extends boolean | null | undefined | offsetArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? offset :
    S extends undefined ? never :
    S extends { include: any } & (offsetArgs | offsetFindManyArgs)
    ? offset  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'match' ? matchGetPayload<S['include'][P]> :
        P extends 'offset_team' ? teamGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (offsetArgs | offsetFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'match' ? matchGetPayload<S['select'][P]> :
        P extends 'offset_team' ? teamGetPayload<S['select'][P]> :  P extends keyof offset ? offset[P] : never
  } 
      : offset


  type offsetCountArgs = 
    Omit<offsetFindManyArgs, 'select' | 'include'> & {
      select?: OffsetCountAggregateInputType | true
    }

  export interface offsetDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Offset that matches the filter.
     * @param {offsetFindUniqueArgs} args - Arguments to find a Offset
     * @example
     * // Get one Offset
     * const offset = await prisma.offset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends offsetFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, offsetFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'offset'> extends True ? Prisma__offsetClient<offsetGetPayload<T>> : Prisma__offsetClient<offsetGetPayload<T> | null, null>

    /**
     * Find one Offset that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {offsetFindUniqueOrThrowArgs} args - Arguments to find a Offset
     * @example
     * // Get one Offset
     * const offset = await prisma.offset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends offsetFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, offsetFindUniqueOrThrowArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Find the first Offset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offsetFindFirstArgs} args - Arguments to find a Offset
     * @example
     * // Get one Offset
     * const offset = await prisma.offset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends offsetFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, offsetFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'offset'> extends True ? Prisma__offsetClient<offsetGetPayload<T>> : Prisma__offsetClient<offsetGetPayload<T> | null, null>

    /**
     * Find the first Offset that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offsetFindFirstOrThrowArgs} args - Arguments to find a Offset
     * @example
     * // Get one Offset
     * const offset = await prisma.offset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends offsetFindFirstOrThrowArgs>(
      args?: SelectSubset<T, offsetFindFirstOrThrowArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Find zero or more Offsets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offsetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offsets
     * const offsets = await prisma.offset.findMany()
     * 
     * // Get first 10 Offsets
     * const offsets = await prisma.offset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offsetWithIdOnly = await prisma.offset.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends offsetFindManyArgs>(
      args?: SelectSubset<T, offsetFindManyArgs>
    ): Prisma.PrismaPromise<Array<offsetGetPayload<T>>>

    /**
     * Create a Offset.
     * @param {offsetCreateArgs} args - Arguments to create a Offset.
     * @example
     * // Create one Offset
     * const Offset = await prisma.offset.create({
     *   data: {
     *     // ... data to create a Offset
     *   }
     * })
     * 
    **/
    create<T extends offsetCreateArgs>(
      args: SelectSubset<T, offsetCreateArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Create many Offsets.
     *     @param {offsetCreateManyArgs} args - Arguments to create many Offsets.
     *     @example
     *     // Create many Offsets
     *     const offset = await prisma.offset.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends offsetCreateManyArgs>(
      args?: SelectSubset<T, offsetCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offset.
     * @param {offsetDeleteArgs} args - Arguments to delete one Offset.
     * @example
     * // Delete one Offset
     * const Offset = await prisma.offset.delete({
     *   where: {
     *     // ... filter to delete one Offset
     *   }
     * })
     * 
    **/
    delete<T extends offsetDeleteArgs>(
      args: SelectSubset<T, offsetDeleteArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Update one Offset.
     * @param {offsetUpdateArgs} args - Arguments to update one Offset.
     * @example
     * // Update one Offset
     * const offset = await prisma.offset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends offsetUpdateArgs>(
      args: SelectSubset<T, offsetUpdateArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Delete zero or more Offsets.
     * @param {offsetDeleteManyArgs} args - Arguments to filter Offsets to delete.
     * @example
     * // Delete a few Offsets
     * const { count } = await prisma.offset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends offsetDeleteManyArgs>(
      args?: SelectSubset<T, offsetDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offsetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offsets
     * const offset = await prisma.offset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends offsetUpdateManyArgs>(
      args: SelectSubset<T, offsetUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offset.
     * @param {offsetUpsertArgs} args - Arguments to update or create a Offset.
     * @example
     * // Update or create a Offset
     * const offset = await prisma.offset.upsert({
     *   create: {
     *     // ... data to create a Offset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offset we want to update
     *   }
     * })
    **/
    upsert<T extends offsetUpsertArgs>(
      args: SelectSubset<T, offsetUpsertArgs>
    ): Prisma__offsetClient<offsetGetPayload<T>>

    /**
     * Count the number of Offsets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offsetCountArgs} args - Arguments to filter Offsets to count.
     * @example
     * // Count the number of Offsets
     * const count = await prisma.offset.count({
     *   where: {
     *     // ... the filter for the Offsets we want to count
     *   }
     * })
    **/
    count<T extends offsetCountArgs>(
      args?: Subset<T, offsetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffsetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffsetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffsetAggregateArgs>(args: Subset<T, OffsetAggregateArgs>): Prisma.PrismaPromise<GetOffsetAggregateType<T>>

    /**
     * Group by Offset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffsetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OffsetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OffsetGroupByArgs['orderBy'] }
        : { orderBy?: OffsetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OffsetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffsetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for offset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__offsetClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    offset_team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * offset base type for findUnique actions
   */
  export type offsetFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter, which offset to fetch.
     */
    where: offsetWhereUniqueInput
  }

  /**
   * offset findUnique
   */
  export interface offsetFindUniqueArgs extends offsetFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offset findUniqueOrThrow
   */
  export type offsetFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter, which offset to fetch.
     */
    where: offsetWhereUniqueInput
  }


  /**
   * offset base type for findFirst actions
   */
  export type offsetFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter, which offset to fetch.
     */
    where?: offsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offsets to fetch.
     */
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offsets.
     */
    cursor?: offsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offsets.
     */
    distinct?: Enumerable<OffsetScalarFieldEnum>
  }

  /**
   * offset findFirst
   */
  export interface offsetFindFirstArgs extends offsetFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * offset findFirstOrThrow
   */
  export type offsetFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter, which offset to fetch.
     */
    where?: offsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offsets to fetch.
     */
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offsets.
     */
    cursor?: offsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offsets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offsets.
     */
    distinct?: Enumerable<OffsetScalarFieldEnum>
  }


  /**
   * offset findMany
   */
  export type offsetFindManyArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter, which offsets to fetch.
     */
    where?: offsetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offsets to fetch.
     */
    orderBy?: Enumerable<offsetOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offsets.
     */
    cursor?: offsetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offsets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offsets.
     */
    skip?: number
    distinct?: Enumerable<OffsetScalarFieldEnum>
  }


  /**
   * offset create
   */
  export type offsetCreateArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * The data needed to create a offset.
     */
    data: XOR<offsetCreateInput, offsetUncheckedCreateInput>
  }


  /**
   * offset createMany
   */
  export type offsetCreateManyArgs = {
    /**
     * The data used to create many offsets.
     */
    data: Enumerable<offsetCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * offset update
   */
  export type offsetUpdateArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * The data needed to update a offset.
     */
    data: XOR<offsetUpdateInput, offsetUncheckedUpdateInput>
    /**
     * Choose, which offset to update.
     */
    where: offsetWhereUniqueInput
  }


  /**
   * offset updateMany
   */
  export type offsetUpdateManyArgs = {
    /**
     * The data used to update offsets.
     */
    data: XOR<offsetUpdateManyMutationInput, offsetUncheckedUpdateManyInput>
    /**
     * Filter which offsets to update
     */
    where?: offsetWhereInput
  }


  /**
   * offset upsert
   */
  export type offsetUpsertArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * The filter to search for the offset to update in case it exists.
     */
    where: offsetWhereUniqueInput
    /**
     * In case the offset found by the `where` argument doesn't exist, create a new offset with this data.
     */
    create: XOR<offsetCreateInput, offsetUncheckedCreateInput>
    /**
     * In case the offset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offsetUpdateInput, offsetUncheckedUpdateInput>
  }


  /**
   * offset delete
   */
  export type offsetDeleteArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
    /**
     * Filter which offset to delete.
     */
    where: offsetWhereUniqueInput
  }


  /**
   * offset deleteMany
   */
  export type offsetDeleteManyArgs = {
    /**
     * Filter which offsets to delete
     */
    where?: offsetWhereInput
  }


  /**
   * offset without action
   */
  export type offsetArgs = {
    /**
     * Select specific fields to fetch from the offset
     */
    select?: offsetSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: offsetInclude | null
  }



  /**
   * Model goal
   */


  export type AggregateGoal = {
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  export type GoalAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    goal_time: number | null
  }

  export type GoalSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    goal_time: number | null
  }

  export type GoalMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    goal_time: number | null
  }

  export type GoalMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    goal_time: number | null
  }

  export type GoalCountAggregateOutputType = {
    id: number
    match_id: number
    player_id: number
    goal_time: number
    _all: number
  }


  export type GoalAvgAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    goal_time?: true
  }

  export type GoalSumAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    goal_time?: true
  }

  export type GoalMinAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    goal_time?: true
  }

  export type GoalMaxAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    goal_time?: true
  }

  export type GoalCountAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    goal_time?: true
    _all?: true
  }

  export type GoalAggregateArgs = {
    /**
     * Filter which goal to aggregate.
     */
    where?: goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of goals to fetch.
     */
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned goals
    **/
    _count?: true | GoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoalMaxAggregateInputType
  }

  export type GetGoalAggregateType<T extends GoalAggregateArgs> = {
        [P in keyof T & keyof AggregateGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoal[P]>
      : GetScalarType<T[P], AggregateGoal[P]>
  }




  export type GoalGroupByArgs = {
    where?: goalWhereInput
    orderBy?: Enumerable<goalOrderByWithAggregationInput>
    by: GoalScalarFieldEnum[]
    having?: goalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoalCountAggregateInputType | true
    _avg?: GoalAvgAggregateInputType
    _sum?: GoalSumAggregateInputType
    _min?: GoalMinAggregateInputType
    _max?: GoalMaxAggregateInputType
  }


  export type GoalGroupByOutputType = {
    id: number
    match_id: number
    player_id: number
    goal_time: number
    _count: GoalCountAggregateOutputType | null
    _avg: GoalAvgAggregateOutputType | null
    _sum: GoalSumAggregateOutputType | null
    _min: GoalMinAggregateOutputType | null
    _max: GoalMaxAggregateOutputType | null
  }

  type GetGoalGroupByPayload<T extends GoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoalGroupByOutputType[P]>
            : GetScalarType<T[P], GoalGroupByOutputType[P]>
        }
      >
    >


  export type goalSelect = {
    id?: boolean
    match_id?: boolean
    player_id?: boolean
    goal_time?: boolean
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }


  export type goalInclude = {
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }

  export type goalGetPayload<S extends boolean | null | undefined | goalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? goal :
    S extends undefined ? never :
    S extends { include: any } & (goalArgs | goalFindManyArgs)
    ? goal  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'player' ? playerGetPayload<S['include'][P]> :
        P extends 'match' ? matchGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (goalArgs | goalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'player' ? playerGetPayload<S['select'][P]> :
        P extends 'match' ? matchGetPayload<S['select'][P]> :  P extends keyof goal ? goal[P] : never
  } 
      : goal


  type goalCountArgs = 
    Omit<goalFindManyArgs, 'select' | 'include'> & {
      select?: GoalCountAggregateInputType | true
    }

  export interface goalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Goal that matches the filter.
     * @param {goalFindUniqueArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends goalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, goalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'goal'> extends True ? Prisma__goalClient<goalGetPayload<T>> : Prisma__goalClient<goalGetPayload<T> | null, null>

    /**
     * Find one Goal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {goalFindUniqueOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends goalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, goalFindUniqueOrThrowArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Find the first Goal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {goalFindFirstArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends goalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, goalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'goal'> extends True ? Prisma__goalClient<goalGetPayload<T>> : Prisma__goalClient<goalGetPayload<T> | null, null>

    /**
     * Find the first Goal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {goalFindFirstOrThrowArgs} args - Arguments to find a Goal
     * @example
     * // Get one Goal
     * const goal = await prisma.goal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends goalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, goalFindFirstOrThrowArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Find zero or more Goals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {goalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Goals
     * const goals = await prisma.goal.findMany()
     * 
     * // Get first 10 Goals
     * const goals = await prisma.goal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const goalWithIdOnly = await prisma.goal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends goalFindManyArgs>(
      args?: SelectSubset<T, goalFindManyArgs>
    ): Prisma.PrismaPromise<Array<goalGetPayload<T>>>

    /**
     * Create a Goal.
     * @param {goalCreateArgs} args - Arguments to create a Goal.
     * @example
     * // Create one Goal
     * const Goal = await prisma.goal.create({
     *   data: {
     *     // ... data to create a Goal
     *   }
     * })
     * 
    **/
    create<T extends goalCreateArgs>(
      args: SelectSubset<T, goalCreateArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Create many Goals.
     *     @param {goalCreateManyArgs} args - Arguments to create many Goals.
     *     @example
     *     // Create many Goals
     *     const goal = await prisma.goal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends goalCreateManyArgs>(
      args?: SelectSubset<T, goalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Goal.
     * @param {goalDeleteArgs} args - Arguments to delete one Goal.
     * @example
     * // Delete one Goal
     * const Goal = await prisma.goal.delete({
     *   where: {
     *     // ... filter to delete one Goal
     *   }
     * })
     * 
    **/
    delete<T extends goalDeleteArgs>(
      args: SelectSubset<T, goalDeleteArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Update one Goal.
     * @param {goalUpdateArgs} args - Arguments to update one Goal.
     * @example
     * // Update one Goal
     * const goal = await prisma.goal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends goalUpdateArgs>(
      args: SelectSubset<T, goalUpdateArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Delete zero or more Goals.
     * @param {goalDeleteManyArgs} args - Arguments to filter Goals to delete.
     * @example
     * // Delete a few Goals
     * const { count } = await prisma.goal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends goalDeleteManyArgs>(
      args?: SelectSubset<T, goalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {goalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Goals
     * const goal = await prisma.goal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends goalUpdateManyArgs>(
      args: SelectSubset<T, goalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Goal.
     * @param {goalUpsertArgs} args - Arguments to update or create a Goal.
     * @example
     * // Update or create a Goal
     * const goal = await prisma.goal.upsert({
     *   create: {
     *     // ... data to create a Goal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Goal we want to update
     *   }
     * })
    **/
    upsert<T extends goalUpsertArgs>(
      args: SelectSubset<T, goalUpsertArgs>
    ): Prisma__goalClient<goalGetPayload<T>>

    /**
     * Count the number of Goals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {goalCountArgs} args - Arguments to filter Goals to count.
     * @example
     * // Count the number of Goals
     * const count = await prisma.goal.count({
     *   where: {
     *     // ... the filter for the Goals we want to count
     *   }
     * })
    **/
    count<T extends goalCountArgs>(
      args?: Subset<T, goalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoalAggregateArgs>(args: Subset<T, GoalAggregateArgs>): Prisma.PrismaPromise<GetGoalAggregateType<T>>

    /**
     * Group by Goal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoalGroupByArgs['orderBy'] }
        : { orderBy?: GoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for goal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__goalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    player<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * goal base type for findUnique actions
   */
  export type goalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter, which goal to fetch.
     */
    where: goalWhereUniqueInput
  }

  /**
   * goal findUnique
   */
  export interface goalFindUniqueArgs extends goalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * goal findUniqueOrThrow
   */
  export type goalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter, which goal to fetch.
     */
    where: goalWhereUniqueInput
  }


  /**
   * goal base type for findFirst actions
   */
  export type goalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter, which goal to fetch.
     */
    where?: goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of goals to fetch.
     */
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for goals.
     */
    cursor?: goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of goals.
     */
    distinct?: Enumerable<GoalScalarFieldEnum>
  }

  /**
   * goal findFirst
   */
  export interface goalFindFirstArgs extends goalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * goal findFirstOrThrow
   */
  export type goalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter, which goal to fetch.
     */
    where?: goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of goals to fetch.
     */
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for goals.
     */
    cursor?: goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` goals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of goals.
     */
    distinct?: Enumerable<GoalScalarFieldEnum>
  }


  /**
   * goal findMany
   */
  export type goalFindManyArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter, which goals to fetch.
     */
    where?: goalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of goals to fetch.
     */
    orderBy?: Enumerable<goalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing goals.
     */
    cursor?: goalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` goals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` goals.
     */
    skip?: number
    distinct?: Enumerable<GoalScalarFieldEnum>
  }


  /**
   * goal create
   */
  export type goalCreateArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * The data needed to create a goal.
     */
    data: XOR<goalCreateInput, goalUncheckedCreateInput>
  }


  /**
   * goal createMany
   */
  export type goalCreateManyArgs = {
    /**
     * The data used to create many goals.
     */
    data: Enumerable<goalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * goal update
   */
  export type goalUpdateArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * The data needed to update a goal.
     */
    data: XOR<goalUpdateInput, goalUncheckedUpdateInput>
    /**
     * Choose, which goal to update.
     */
    where: goalWhereUniqueInput
  }


  /**
   * goal updateMany
   */
  export type goalUpdateManyArgs = {
    /**
     * The data used to update goals.
     */
    data: XOR<goalUpdateManyMutationInput, goalUncheckedUpdateManyInput>
    /**
     * Filter which goals to update
     */
    where?: goalWhereInput
  }


  /**
   * goal upsert
   */
  export type goalUpsertArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * The filter to search for the goal to update in case it exists.
     */
    where: goalWhereUniqueInput
    /**
     * In case the goal found by the `where` argument doesn't exist, create a new goal with this data.
     */
    create: XOR<goalCreateInput, goalUncheckedCreateInput>
    /**
     * In case the goal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<goalUpdateInput, goalUncheckedUpdateInput>
  }


  /**
   * goal delete
   */
  export type goalDeleteArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
    /**
     * Filter which goal to delete.
     */
    where: goalWhereUniqueInput
  }


  /**
   * goal deleteMany
   */
  export type goalDeleteManyArgs = {
    /**
     * Filter which goals to delete
     */
    where?: goalWhereInput
  }


  /**
   * goal without action
   */
  export type goalArgs = {
    /**
     * Select specific fields to fetch from the goal
     */
    select?: goalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: goalInclude | null
  }



  /**
   * Model foul
   */


  export type AggregateFoul = {
    _count: FoulCountAggregateOutputType | null
    _avg: FoulAvgAggregateOutputType | null
    _sum: FoulSumAggregateOutputType | null
    _min: FoulMinAggregateOutputType | null
    _max: FoulMaxAggregateOutputType | null
  }

  export type FoulAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type FoulSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    player_id: number | null
  }

  export type FoulMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    player_id: number | null
    type: string | null
  }

  export type FoulMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    player_id: number | null
    type: string | null
  }

  export type FoulCountAggregateOutputType = {
    id: number
    match_id: number
    team_id: number
    player_id: number
    type: number
    _all: number
  }


  export type FoulAvgAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    player_id?: true
  }

  export type FoulSumAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    player_id?: true
  }

  export type FoulMinAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    player_id?: true
    type?: true
  }

  export type FoulMaxAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    player_id?: true
    type?: true
  }

  export type FoulCountAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    player_id?: true
    type?: true
    _all?: true
  }

  export type FoulAggregateArgs = {
    /**
     * Filter which foul to aggregate.
     */
    where?: foulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fouls to fetch.
     */
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: foulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fouls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fouls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fouls
    **/
    _count?: true | FoulCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoulAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoulSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoulMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoulMaxAggregateInputType
  }

  export type GetFoulAggregateType<T extends FoulAggregateArgs> = {
        [P in keyof T & keyof AggregateFoul]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoul[P]>
      : GetScalarType<T[P], AggregateFoul[P]>
  }




  export type FoulGroupByArgs = {
    where?: foulWhereInput
    orderBy?: Enumerable<foulOrderByWithAggregationInput>
    by: FoulScalarFieldEnum[]
    having?: foulScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoulCountAggregateInputType | true
    _avg?: FoulAvgAggregateInputType
    _sum?: FoulSumAggregateInputType
    _min?: FoulMinAggregateInputType
    _max?: FoulMaxAggregateInputType
  }


  export type FoulGroupByOutputType = {
    id: number
    match_id: number
    team_id: number
    player_id: number
    type: string | null
    _count: FoulCountAggregateOutputType | null
    _avg: FoulAvgAggregateOutputType | null
    _sum: FoulSumAggregateOutputType | null
    _min: FoulMinAggregateOutputType | null
    _max: FoulMaxAggregateOutputType | null
  }

  type GetFoulGroupByPayload<T extends FoulGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FoulGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoulGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoulGroupByOutputType[P]>
            : GetScalarType<T[P], FoulGroupByOutputType[P]>
        }
      >
    >


  export type foulSelect = {
    id?: boolean
    match_id?: boolean
    team_id?: boolean
    player_id?: boolean
    type?: boolean
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }


  export type foulInclude = {
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }

  export type foulGetPayload<S extends boolean | null | undefined | foulArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? foul :
    S extends undefined ? never :
    S extends { include: any } & (foulArgs | foulFindManyArgs)
    ? foul  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'player' ? playerGetPayload<S['include'][P]> :
        P extends 'match' ? matchGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (foulArgs | foulFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'player' ? playerGetPayload<S['select'][P]> :
        P extends 'match' ? matchGetPayload<S['select'][P]> :  P extends keyof foul ? foul[P] : never
  } 
      : foul


  type foulCountArgs = 
    Omit<foulFindManyArgs, 'select' | 'include'> & {
      select?: FoulCountAggregateInputType | true
    }

  export interface foulDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Foul that matches the filter.
     * @param {foulFindUniqueArgs} args - Arguments to find a Foul
     * @example
     * // Get one Foul
     * const foul = await prisma.foul.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends foulFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, foulFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'foul'> extends True ? Prisma__foulClient<foulGetPayload<T>> : Prisma__foulClient<foulGetPayload<T> | null, null>

    /**
     * Find one Foul that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {foulFindUniqueOrThrowArgs} args - Arguments to find a Foul
     * @example
     * // Get one Foul
     * const foul = await prisma.foul.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends foulFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, foulFindUniqueOrThrowArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Find the first Foul that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foulFindFirstArgs} args - Arguments to find a Foul
     * @example
     * // Get one Foul
     * const foul = await prisma.foul.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends foulFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, foulFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'foul'> extends True ? Prisma__foulClient<foulGetPayload<T>> : Prisma__foulClient<foulGetPayload<T> | null, null>

    /**
     * Find the first Foul that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foulFindFirstOrThrowArgs} args - Arguments to find a Foul
     * @example
     * // Get one Foul
     * const foul = await prisma.foul.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends foulFindFirstOrThrowArgs>(
      args?: SelectSubset<T, foulFindFirstOrThrowArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Find zero or more Fouls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foulFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fouls
     * const fouls = await prisma.foul.findMany()
     * 
     * // Get first 10 Fouls
     * const fouls = await prisma.foul.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foulWithIdOnly = await prisma.foul.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends foulFindManyArgs>(
      args?: SelectSubset<T, foulFindManyArgs>
    ): Prisma.PrismaPromise<Array<foulGetPayload<T>>>

    /**
     * Create a Foul.
     * @param {foulCreateArgs} args - Arguments to create a Foul.
     * @example
     * // Create one Foul
     * const Foul = await prisma.foul.create({
     *   data: {
     *     // ... data to create a Foul
     *   }
     * })
     * 
    **/
    create<T extends foulCreateArgs>(
      args: SelectSubset<T, foulCreateArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Create many Fouls.
     *     @param {foulCreateManyArgs} args - Arguments to create many Fouls.
     *     @example
     *     // Create many Fouls
     *     const foul = await prisma.foul.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends foulCreateManyArgs>(
      args?: SelectSubset<T, foulCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foul.
     * @param {foulDeleteArgs} args - Arguments to delete one Foul.
     * @example
     * // Delete one Foul
     * const Foul = await prisma.foul.delete({
     *   where: {
     *     // ... filter to delete one Foul
     *   }
     * })
     * 
    **/
    delete<T extends foulDeleteArgs>(
      args: SelectSubset<T, foulDeleteArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Update one Foul.
     * @param {foulUpdateArgs} args - Arguments to update one Foul.
     * @example
     * // Update one Foul
     * const foul = await prisma.foul.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends foulUpdateArgs>(
      args: SelectSubset<T, foulUpdateArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Delete zero or more Fouls.
     * @param {foulDeleteManyArgs} args - Arguments to filter Fouls to delete.
     * @example
     * // Delete a few Fouls
     * const { count } = await prisma.foul.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends foulDeleteManyArgs>(
      args?: SelectSubset<T, foulDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fouls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foulUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fouls
     * const foul = await prisma.foul.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends foulUpdateManyArgs>(
      args: SelectSubset<T, foulUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foul.
     * @param {foulUpsertArgs} args - Arguments to update or create a Foul.
     * @example
     * // Update or create a Foul
     * const foul = await prisma.foul.upsert({
     *   create: {
     *     // ... data to create a Foul
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foul we want to update
     *   }
     * })
    **/
    upsert<T extends foulUpsertArgs>(
      args: SelectSubset<T, foulUpsertArgs>
    ): Prisma__foulClient<foulGetPayload<T>>

    /**
     * Count the number of Fouls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {foulCountArgs} args - Arguments to filter Fouls to count.
     * @example
     * // Count the number of Fouls
     * const count = await prisma.foul.count({
     *   where: {
     *     // ... the filter for the Fouls we want to count
     *   }
     * })
    **/
    count<T extends foulCountArgs>(
      args?: Subset<T, foulCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoulCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foul.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoulAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoulAggregateArgs>(args: Subset<T, FoulAggregateArgs>): Prisma.PrismaPromise<GetFoulAggregateType<T>>

    /**
     * Group by Foul.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoulGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoulGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoulGroupByArgs['orderBy'] }
        : { orderBy?: FoulGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoulGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoulGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for foul.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__foulClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    player<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * foul base type for findUnique actions
   */
  export type foulFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter, which foul to fetch.
     */
    where: foulWhereUniqueInput
  }

  /**
   * foul findUnique
   */
  export interface foulFindUniqueArgs extends foulFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * foul findUniqueOrThrow
   */
  export type foulFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter, which foul to fetch.
     */
    where: foulWhereUniqueInput
  }


  /**
   * foul base type for findFirst actions
   */
  export type foulFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter, which foul to fetch.
     */
    where?: foulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fouls to fetch.
     */
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fouls.
     */
    cursor?: foulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fouls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fouls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fouls.
     */
    distinct?: Enumerable<FoulScalarFieldEnum>
  }

  /**
   * foul findFirst
   */
  export interface foulFindFirstArgs extends foulFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * foul findFirstOrThrow
   */
  export type foulFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter, which foul to fetch.
     */
    where?: foulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fouls to fetch.
     */
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fouls.
     */
    cursor?: foulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fouls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fouls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fouls.
     */
    distinct?: Enumerable<FoulScalarFieldEnum>
  }


  /**
   * foul findMany
   */
  export type foulFindManyArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter, which fouls to fetch.
     */
    where?: foulWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fouls to fetch.
     */
    orderBy?: Enumerable<foulOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fouls.
     */
    cursor?: foulWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fouls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fouls.
     */
    skip?: number
    distinct?: Enumerable<FoulScalarFieldEnum>
  }


  /**
   * foul create
   */
  export type foulCreateArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * The data needed to create a foul.
     */
    data: XOR<foulCreateInput, foulUncheckedCreateInput>
  }


  /**
   * foul createMany
   */
  export type foulCreateManyArgs = {
    /**
     * The data used to create many fouls.
     */
    data: Enumerable<foulCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * foul update
   */
  export type foulUpdateArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * The data needed to update a foul.
     */
    data: XOR<foulUpdateInput, foulUncheckedUpdateInput>
    /**
     * Choose, which foul to update.
     */
    where: foulWhereUniqueInput
  }


  /**
   * foul updateMany
   */
  export type foulUpdateManyArgs = {
    /**
     * The data used to update fouls.
     */
    data: XOR<foulUpdateManyMutationInput, foulUncheckedUpdateManyInput>
    /**
     * Filter which fouls to update
     */
    where?: foulWhereInput
  }


  /**
   * foul upsert
   */
  export type foulUpsertArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * The filter to search for the foul to update in case it exists.
     */
    where: foulWhereUniqueInput
    /**
     * In case the foul found by the `where` argument doesn't exist, create a new foul with this data.
     */
    create: XOR<foulCreateInput, foulUncheckedCreateInput>
    /**
     * In case the foul was found with the provided `where` argument, update it with this data.
     */
    update: XOR<foulUpdateInput, foulUncheckedUpdateInput>
  }


  /**
   * foul delete
   */
  export type foulDeleteArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
    /**
     * Filter which foul to delete.
     */
    where: foulWhereUniqueInput
  }


  /**
   * foul deleteMany
   */
  export type foulDeleteManyArgs = {
    /**
     * Filter which fouls to delete
     */
    where?: foulWhereInput
  }


  /**
   * foul without action
   */
  export type foulArgs = {
    /**
     * Select specific fields to fetch from the foul
     */
    select?: foulSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: foulInclude | null
  }



  /**
   * Model injury
   */


  export type AggregateInjury = {
    _count: InjuryCountAggregateOutputType | null
    _avg: InjuryAvgAggregateOutputType | null
    _sum: InjurySumAggregateOutputType | null
    _min: InjuryMinAggregateOutputType | null
    _max: InjuryMaxAggregateOutputType | null
  }

  export type InjuryAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
  }

  export type InjurySumAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
  }

  export type InjuryMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    injury_type: string | null
  }

  export type InjuryMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    injury_type: string | null
  }

  export type InjuryCountAggregateOutputType = {
    id: number
    match_id: number
    player_id: number
    injury_type: number
    _all: number
  }


  export type InjuryAvgAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
  }

  export type InjurySumAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
  }

  export type InjuryMinAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    injury_type?: true
  }

  export type InjuryMaxAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    injury_type?: true
  }

  export type InjuryCountAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    injury_type?: true
    _all?: true
  }

  export type InjuryAggregateArgs = {
    /**
     * Filter which injury to aggregate.
     */
    where?: injuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injuries to fetch.
     */
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: injuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned injuries
    **/
    _count?: true | InjuryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InjuryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InjurySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InjuryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InjuryMaxAggregateInputType
  }

  export type GetInjuryAggregateType<T extends InjuryAggregateArgs> = {
        [P in keyof T & keyof AggregateInjury]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInjury[P]>
      : GetScalarType<T[P], AggregateInjury[P]>
  }




  export type InjuryGroupByArgs = {
    where?: injuryWhereInput
    orderBy?: Enumerable<injuryOrderByWithAggregationInput>
    by: InjuryScalarFieldEnum[]
    having?: injuryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InjuryCountAggregateInputType | true
    _avg?: InjuryAvgAggregateInputType
    _sum?: InjurySumAggregateInputType
    _min?: InjuryMinAggregateInputType
    _max?: InjuryMaxAggregateInputType
  }


  export type InjuryGroupByOutputType = {
    id: number
    match_id: number
    player_id: number
    injury_type: string
    _count: InjuryCountAggregateOutputType | null
    _avg: InjuryAvgAggregateOutputType | null
    _sum: InjurySumAggregateOutputType | null
    _min: InjuryMinAggregateOutputType | null
    _max: InjuryMaxAggregateOutputType | null
  }

  type GetInjuryGroupByPayload<T extends InjuryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<InjuryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InjuryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InjuryGroupByOutputType[P]>
            : GetScalarType<T[P], InjuryGroupByOutputType[P]>
        }
      >
    >


  export type injurySelect = {
    id?: boolean
    match_id?: boolean
    player_id?: boolean
    injury_type?: boolean
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }


  export type injuryInclude = {
    player?: boolean | playerArgs
    match?: boolean | matchArgs
  }

  export type injuryGetPayload<S extends boolean | null | undefined | injuryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? injury :
    S extends undefined ? never :
    S extends { include: any } & (injuryArgs | injuryFindManyArgs)
    ? injury  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'player' ? playerGetPayload<S['include'][P]> :
        P extends 'match' ? matchGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (injuryArgs | injuryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'player' ? playerGetPayload<S['select'][P]> :
        P extends 'match' ? matchGetPayload<S['select'][P]> :  P extends keyof injury ? injury[P] : never
  } 
      : injury


  type injuryCountArgs = 
    Omit<injuryFindManyArgs, 'select' | 'include'> & {
      select?: InjuryCountAggregateInputType | true
    }

  export interface injuryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Injury that matches the filter.
     * @param {injuryFindUniqueArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends injuryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, injuryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'injury'> extends True ? Prisma__injuryClient<injuryGetPayload<T>> : Prisma__injuryClient<injuryGetPayload<T> | null, null>

    /**
     * Find one Injury that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {injuryFindUniqueOrThrowArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends injuryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, injuryFindUniqueOrThrowArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Find the first Injury that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injuryFindFirstArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends injuryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, injuryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'injury'> extends True ? Prisma__injuryClient<injuryGetPayload<T>> : Prisma__injuryClient<injuryGetPayload<T> | null, null>

    /**
     * Find the first Injury that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injuryFindFirstOrThrowArgs} args - Arguments to find a Injury
     * @example
     * // Get one Injury
     * const injury = await prisma.injury.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends injuryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, injuryFindFirstOrThrowArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Find zero or more Injuries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injuryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Injuries
     * const injuries = await prisma.injury.findMany()
     * 
     * // Get first 10 Injuries
     * const injuries = await prisma.injury.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const injuryWithIdOnly = await prisma.injury.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends injuryFindManyArgs>(
      args?: SelectSubset<T, injuryFindManyArgs>
    ): Prisma.PrismaPromise<Array<injuryGetPayload<T>>>

    /**
     * Create a Injury.
     * @param {injuryCreateArgs} args - Arguments to create a Injury.
     * @example
     * // Create one Injury
     * const Injury = await prisma.injury.create({
     *   data: {
     *     // ... data to create a Injury
     *   }
     * })
     * 
    **/
    create<T extends injuryCreateArgs>(
      args: SelectSubset<T, injuryCreateArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Create many Injuries.
     *     @param {injuryCreateManyArgs} args - Arguments to create many Injuries.
     *     @example
     *     // Create many Injuries
     *     const injury = await prisma.injury.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends injuryCreateManyArgs>(
      args?: SelectSubset<T, injuryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Injury.
     * @param {injuryDeleteArgs} args - Arguments to delete one Injury.
     * @example
     * // Delete one Injury
     * const Injury = await prisma.injury.delete({
     *   where: {
     *     // ... filter to delete one Injury
     *   }
     * })
     * 
    **/
    delete<T extends injuryDeleteArgs>(
      args: SelectSubset<T, injuryDeleteArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Update one Injury.
     * @param {injuryUpdateArgs} args - Arguments to update one Injury.
     * @example
     * // Update one Injury
     * const injury = await prisma.injury.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends injuryUpdateArgs>(
      args: SelectSubset<T, injuryUpdateArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Delete zero or more Injuries.
     * @param {injuryDeleteManyArgs} args - Arguments to filter Injuries to delete.
     * @example
     * // Delete a few Injuries
     * const { count } = await prisma.injury.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends injuryDeleteManyArgs>(
      args?: SelectSubset<T, injuryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Injuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injuryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Injuries
     * const injury = await prisma.injury.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends injuryUpdateManyArgs>(
      args: SelectSubset<T, injuryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Injury.
     * @param {injuryUpsertArgs} args - Arguments to update or create a Injury.
     * @example
     * // Update or create a Injury
     * const injury = await prisma.injury.upsert({
     *   create: {
     *     // ... data to create a Injury
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Injury we want to update
     *   }
     * })
    **/
    upsert<T extends injuryUpsertArgs>(
      args: SelectSubset<T, injuryUpsertArgs>
    ): Prisma__injuryClient<injuryGetPayload<T>>

    /**
     * Count the number of Injuries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {injuryCountArgs} args - Arguments to filter Injuries to count.
     * @example
     * // Count the number of Injuries
     * const count = await prisma.injury.count({
     *   where: {
     *     // ... the filter for the Injuries we want to count
     *   }
     * })
    **/
    count<T extends injuryCountArgs>(
      args?: Subset<T, injuryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InjuryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Injury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InjuryAggregateArgs>(args: Subset<T, InjuryAggregateArgs>): Prisma.PrismaPromise<GetInjuryAggregateType<T>>

    /**
     * Group by Injury.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InjuryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InjuryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InjuryGroupByArgs['orderBy'] }
        : { orderBy?: InjuryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InjuryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInjuryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for injury.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__injuryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    player<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * injury base type for findUnique actions
   */
  export type injuryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter, which injury to fetch.
     */
    where: injuryWhereUniqueInput
  }

  /**
   * injury findUnique
   */
  export interface injuryFindUniqueArgs extends injuryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * injury findUniqueOrThrow
   */
  export type injuryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter, which injury to fetch.
     */
    where: injuryWhereUniqueInput
  }


  /**
   * injury base type for findFirst actions
   */
  export type injuryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter, which injury to fetch.
     */
    where?: injuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injuries to fetch.
     */
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for injuries.
     */
    cursor?: injuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of injuries.
     */
    distinct?: Enumerable<InjuryScalarFieldEnum>
  }

  /**
   * injury findFirst
   */
  export interface injuryFindFirstArgs extends injuryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * injury findFirstOrThrow
   */
  export type injuryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter, which injury to fetch.
     */
    where?: injuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injuries to fetch.
     */
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for injuries.
     */
    cursor?: injuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injuries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of injuries.
     */
    distinct?: Enumerable<InjuryScalarFieldEnum>
  }


  /**
   * injury findMany
   */
  export type injuryFindManyArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter, which injuries to fetch.
     */
    where?: injuryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of injuries to fetch.
     */
    orderBy?: Enumerable<injuryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing injuries.
     */
    cursor?: injuryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` injuries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` injuries.
     */
    skip?: number
    distinct?: Enumerable<InjuryScalarFieldEnum>
  }


  /**
   * injury create
   */
  export type injuryCreateArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * The data needed to create a injury.
     */
    data: XOR<injuryCreateInput, injuryUncheckedCreateInput>
  }


  /**
   * injury createMany
   */
  export type injuryCreateManyArgs = {
    /**
     * The data used to create many injuries.
     */
    data: Enumerable<injuryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * injury update
   */
  export type injuryUpdateArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * The data needed to update a injury.
     */
    data: XOR<injuryUpdateInput, injuryUncheckedUpdateInput>
    /**
     * Choose, which injury to update.
     */
    where: injuryWhereUniqueInput
  }


  /**
   * injury updateMany
   */
  export type injuryUpdateManyArgs = {
    /**
     * The data used to update injuries.
     */
    data: XOR<injuryUpdateManyMutationInput, injuryUncheckedUpdateManyInput>
    /**
     * Filter which injuries to update
     */
    where?: injuryWhereInput
  }


  /**
   * injury upsert
   */
  export type injuryUpsertArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * The filter to search for the injury to update in case it exists.
     */
    where: injuryWhereUniqueInput
    /**
     * In case the injury found by the `where` argument doesn't exist, create a new injury with this data.
     */
    create: XOR<injuryCreateInput, injuryUncheckedCreateInput>
    /**
     * In case the injury was found with the provided `where` argument, update it with this data.
     */
    update: XOR<injuryUpdateInput, injuryUncheckedUpdateInput>
  }


  /**
   * injury delete
   */
  export type injuryDeleteArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
    /**
     * Filter which injury to delete.
     */
    where: injuryWhereUniqueInput
  }


  /**
   * injury deleteMany
   */
  export type injuryDeleteManyArgs = {
    /**
     * Filter which injuries to delete
     */
    where?: injuryWhereInput
  }


  /**
   * injury without action
   */
  export type injuryArgs = {
    /**
     * Select specific fields to fetch from the injury
     */
    select?: injurySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: injuryInclude | null
  }



  /**
   * Model ballPossession
   */


  export type AggregateBallPossession = {
    _count: BallPossessionCountAggregateOutputType | null
    _avg: BallPossessionAvgAggregateOutputType | null
    _sum: BallPossessionSumAggregateOutputType | null
    _min: BallPossessionMinAggregateOutputType | null
    _max: BallPossessionMaxAggregateOutputType | null
  }

  export type BallPossessionAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    possession_time: number | null
  }

  export type BallPossessionSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    possession_time: number | null
  }

  export type BallPossessionMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    possession_time: number | null
  }

  export type BallPossessionMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    team_id: number | null
    possession_time: number | null
  }

  export type BallPossessionCountAggregateOutputType = {
    id: number
    match_id: number
    team_id: number
    possession_time: number
    _all: number
  }


  export type BallPossessionAvgAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    possession_time?: true
  }

  export type BallPossessionSumAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    possession_time?: true
  }

  export type BallPossessionMinAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    possession_time?: true
  }

  export type BallPossessionMaxAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    possession_time?: true
  }

  export type BallPossessionCountAggregateInputType = {
    id?: true
    match_id?: true
    team_id?: true
    possession_time?: true
    _all?: true
  }

  export type BallPossessionAggregateArgs = {
    /**
     * Filter which ballPossession to aggregate.
     */
    where?: ballPossessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ballPossessions to fetch.
     */
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ballPossessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ballPossessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ballPossessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ballPossessions
    **/
    _count?: true | BallPossessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BallPossessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BallPossessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BallPossessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BallPossessionMaxAggregateInputType
  }

  export type GetBallPossessionAggregateType<T extends BallPossessionAggregateArgs> = {
        [P in keyof T & keyof AggregateBallPossession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBallPossession[P]>
      : GetScalarType<T[P], AggregateBallPossession[P]>
  }




  export type BallPossessionGroupByArgs = {
    where?: ballPossessionWhereInput
    orderBy?: Enumerable<ballPossessionOrderByWithAggregationInput>
    by: BallPossessionScalarFieldEnum[]
    having?: ballPossessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BallPossessionCountAggregateInputType | true
    _avg?: BallPossessionAvgAggregateInputType
    _sum?: BallPossessionSumAggregateInputType
    _min?: BallPossessionMinAggregateInputType
    _max?: BallPossessionMaxAggregateInputType
  }


  export type BallPossessionGroupByOutputType = {
    id: number
    match_id: number
    team_id: number
    possession_time: number
    _count: BallPossessionCountAggregateOutputType | null
    _avg: BallPossessionAvgAggregateOutputType | null
    _sum: BallPossessionSumAggregateOutputType | null
    _min: BallPossessionMinAggregateOutputType | null
    _max: BallPossessionMaxAggregateOutputType | null
  }

  type GetBallPossessionGroupByPayload<T extends BallPossessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BallPossessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BallPossessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BallPossessionGroupByOutputType[P]>
            : GetScalarType<T[P], BallPossessionGroupByOutputType[P]>
        }
      >
    >


  export type ballPossessionSelect = {
    id?: boolean
    match_id?: boolean
    team_id?: boolean
    possession_time?: boolean
    match?: boolean | matchArgs
    team?: boolean | teamArgs
  }


  export type ballPossessionInclude = {
    match?: boolean | matchArgs
    team?: boolean | teamArgs
  }

  export type ballPossessionGetPayload<S extends boolean | null | undefined | ballPossessionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ballPossession :
    S extends undefined ? never :
    S extends { include: any } & (ballPossessionArgs | ballPossessionFindManyArgs)
    ? ballPossession  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'match' ? matchGetPayload<S['include'][P]> :
        P extends 'team' ? teamGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ballPossessionArgs | ballPossessionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'match' ? matchGetPayload<S['select'][P]> :
        P extends 'team' ? teamGetPayload<S['select'][P]> :  P extends keyof ballPossession ? ballPossession[P] : never
  } 
      : ballPossession


  type ballPossessionCountArgs = 
    Omit<ballPossessionFindManyArgs, 'select' | 'include'> & {
      select?: BallPossessionCountAggregateInputType | true
    }

  export interface ballPossessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one BallPossession that matches the filter.
     * @param {ballPossessionFindUniqueArgs} args - Arguments to find a BallPossession
     * @example
     * // Get one BallPossession
     * const ballPossession = await prisma.ballPossession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ballPossessionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ballPossessionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ballPossession'> extends True ? Prisma__ballPossessionClient<ballPossessionGetPayload<T>> : Prisma__ballPossessionClient<ballPossessionGetPayload<T> | null, null>

    /**
     * Find one BallPossession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ballPossessionFindUniqueOrThrowArgs} args - Arguments to find a BallPossession
     * @example
     * // Get one BallPossession
     * const ballPossession = await prisma.ballPossession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ballPossessionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ballPossessionFindUniqueOrThrowArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Find the first BallPossession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ballPossessionFindFirstArgs} args - Arguments to find a BallPossession
     * @example
     * // Get one BallPossession
     * const ballPossession = await prisma.ballPossession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ballPossessionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ballPossessionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ballPossession'> extends True ? Prisma__ballPossessionClient<ballPossessionGetPayload<T>> : Prisma__ballPossessionClient<ballPossessionGetPayload<T> | null, null>

    /**
     * Find the first BallPossession that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ballPossessionFindFirstOrThrowArgs} args - Arguments to find a BallPossession
     * @example
     * // Get one BallPossession
     * const ballPossession = await prisma.ballPossession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ballPossessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ballPossessionFindFirstOrThrowArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Find zero or more BallPossessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ballPossessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BallPossessions
     * const ballPossessions = await prisma.ballPossession.findMany()
     * 
     * // Get first 10 BallPossessions
     * const ballPossessions = await prisma.ballPossession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ballPossessionWithIdOnly = await prisma.ballPossession.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ballPossessionFindManyArgs>(
      args?: SelectSubset<T, ballPossessionFindManyArgs>
    ): Prisma.PrismaPromise<Array<ballPossessionGetPayload<T>>>

    /**
     * Create a BallPossession.
     * @param {ballPossessionCreateArgs} args - Arguments to create a BallPossession.
     * @example
     * // Create one BallPossession
     * const BallPossession = await prisma.ballPossession.create({
     *   data: {
     *     // ... data to create a BallPossession
     *   }
     * })
     * 
    **/
    create<T extends ballPossessionCreateArgs>(
      args: SelectSubset<T, ballPossessionCreateArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Create many BallPossessions.
     *     @param {ballPossessionCreateManyArgs} args - Arguments to create many BallPossessions.
     *     @example
     *     // Create many BallPossessions
     *     const ballPossession = await prisma.ballPossession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ballPossessionCreateManyArgs>(
      args?: SelectSubset<T, ballPossessionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BallPossession.
     * @param {ballPossessionDeleteArgs} args - Arguments to delete one BallPossession.
     * @example
     * // Delete one BallPossession
     * const BallPossession = await prisma.ballPossession.delete({
     *   where: {
     *     // ... filter to delete one BallPossession
     *   }
     * })
     * 
    **/
    delete<T extends ballPossessionDeleteArgs>(
      args: SelectSubset<T, ballPossessionDeleteArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Update one BallPossession.
     * @param {ballPossessionUpdateArgs} args - Arguments to update one BallPossession.
     * @example
     * // Update one BallPossession
     * const ballPossession = await prisma.ballPossession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ballPossessionUpdateArgs>(
      args: SelectSubset<T, ballPossessionUpdateArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Delete zero or more BallPossessions.
     * @param {ballPossessionDeleteManyArgs} args - Arguments to filter BallPossessions to delete.
     * @example
     * // Delete a few BallPossessions
     * const { count } = await prisma.ballPossession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ballPossessionDeleteManyArgs>(
      args?: SelectSubset<T, ballPossessionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BallPossessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ballPossessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BallPossessions
     * const ballPossession = await prisma.ballPossession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ballPossessionUpdateManyArgs>(
      args: SelectSubset<T, ballPossessionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BallPossession.
     * @param {ballPossessionUpsertArgs} args - Arguments to update or create a BallPossession.
     * @example
     * // Update or create a BallPossession
     * const ballPossession = await prisma.ballPossession.upsert({
     *   create: {
     *     // ... data to create a BallPossession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BallPossession we want to update
     *   }
     * })
    **/
    upsert<T extends ballPossessionUpsertArgs>(
      args: SelectSubset<T, ballPossessionUpsertArgs>
    ): Prisma__ballPossessionClient<ballPossessionGetPayload<T>>

    /**
     * Count the number of BallPossessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ballPossessionCountArgs} args - Arguments to filter BallPossessions to count.
     * @example
     * // Count the number of BallPossessions
     * const count = await prisma.ballPossession.count({
     *   where: {
     *     // ... the filter for the BallPossessions we want to count
     *   }
     * })
    **/
    count<T extends ballPossessionCountArgs>(
      args?: Subset<T, ballPossessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BallPossessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BallPossession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallPossessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BallPossessionAggregateArgs>(args: Subset<T, BallPossessionAggregateArgs>): Prisma.PrismaPromise<GetBallPossessionAggregateType<T>>

    /**
     * Group by BallPossession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BallPossessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BallPossessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BallPossessionGroupByArgs['orderBy'] }
        : { orderBy?: BallPossessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BallPossessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBallPossessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ballPossession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ballPossessionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    team<T extends teamArgs= {}>(args?: Subset<T, teamArgs>): Prisma__teamClient<teamGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ballPossession base type for findUnique actions
   */
  export type ballPossessionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter, which ballPossession to fetch.
     */
    where: ballPossessionWhereUniqueInput
  }

  /**
   * ballPossession findUnique
   */
  export interface ballPossessionFindUniqueArgs extends ballPossessionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ballPossession findUniqueOrThrow
   */
  export type ballPossessionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter, which ballPossession to fetch.
     */
    where: ballPossessionWhereUniqueInput
  }


  /**
   * ballPossession base type for findFirst actions
   */
  export type ballPossessionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter, which ballPossession to fetch.
     */
    where?: ballPossessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ballPossessions to fetch.
     */
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ballPossessions.
     */
    cursor?: ballPossessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ballPossessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ballPossessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ballPossessions.
     */
    distinct?: Enumerable<BallPossessionScalarFieldEnum>
  }

  /**
   * ballPossession findFirst
   */
  export interface ballPossessionFindFirstArgs extends ballPossessionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ballPossession findFirstOrThrow
   */
  export type ballPossessionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter, which ballPossession to fetch.
     */
    where?: ballPossessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ballPossessions to fetch.
     */
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ballPossessions.
     */
    cursor?: ballPossessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ballPossessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ballPossessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ballPossessions.
     */
    distinct?: Enumerable<BallPossessionScalarFieldEnum>
  }


  /**
   * ballPossession findMany
   */
  export type ballPossessionFindManyArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter, which ballPossessions to fetch.
     */
    where?: ballPossessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ballPossessions to fetch.
     */
    orderBy?: Enumerable<ballPossessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ballPossessions.
     */
    cursor?: ballPossessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ballPossessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ballPossessions.
     */
    skip?: number
    distinct?: Enumerable<BallPossessionScalarFieldEnum>
  }


  /**
   * ballPossession create
   */
  export type ballPossessionCreateArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * The data needed to create a ballPossession.
     */
    data: XOR<ballPossessionCreateInput, ballPossessionUncheckedCreateInput>
  }


  /**
   * ballPossession createMany
   */
  export type ballPossessionCreateManyArgs = {
    /**
     * The data used to create many ballPossessions.
     */
    data: Enumerable<ballPossessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ballPossession update
   */
  export type ballPossessionUpdateArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * The data needed to update a ballPossession.
     */
    data: XOR<ballPossessionUpdateInput, ballPossessionUncheckedUpdateInput>
    /**
     * Choose, which ballPossession to update.
     */
    where: ballPossessionWhereUniqueInput
  }


  /**
   * ballPossession updateMany
   */
  export type ballPossessionUpdateManyArgs = {
    /**
     * The data used to update ballPossessions.
     */
    data: XOR<ballPossessionUpdateManyMutationInput, ballPossessionUncheckedUpdateManyInput>
    /**
     * Filter which ballPossessions to update
     */
    where?: ballPossessionWhereInput
  }


  /**
   * ballPossession upsert
   */
  export type ballPossessionUpsertArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * The filter to search for the ballPossession to update in case it exists.
     */
    where: ballPossessionWhereUniqueInput
    /**
     * In case the ballPossession found by the `where` argument doesn't exist, create a new ballPossession with this data.
     */
    create: XOR<ballPossessionCreateInput, ballPossessionUncheckedCreateInput>
    /**
     * In case the ballPossession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ballPossessionUpdateInput, ballPossessionUncheckedUpdateInput>
  }


  /**
   * ballPossession delete
   */
  export type ballPossessionDeleteArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
    /**
     * Filter which ballPossession to delete.
     */
    where: ballPossessionWhereUniqueInput
  }


  /**
   * ballPossession deleteMany
   */
  export type ballPossessionDeleteManyArgs = {
    /**
     * Filter which ballPossessions to delete
     */
    where?: ballPossessionWhereInput
  }


  /**
   * ballPossession without action
   */
  export type ballPossessionArgs = {
    /**
     * Select specific fields to fetch from the ballPossession
     */
    select?: ballPossessionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ballPossessionInclude | null
  }



  /**
   * Model card
   */


  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    card_time: number | null
  }

  export type CardSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    card_time: number | null
  }

  export type CardMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    card_type: string | null
    card_time: number | null
  }

  export type CardMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_id: number | null
    card_type: string | null
    card_time: number | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    match_id: number
    player_id: number
    card_type: number
    card_time: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    card_time?: true
  }

  export type CardSumAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    card_time?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    card_type?: true
    card_time?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    card_type?: true
    card_time?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    match_id?: true
    player_id?: true
    card_type?: true
    card_time?: true
    _all?: true
  }

  export type CardAggregateArgs = {
    /**
     * Filter which card to aggregate.
     */
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     */
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs = {
    where?: cardWhereInput
    orderBy?: Enumerable<cardOrderByWithAggregationInput>
    by: CardScalarFieldEnum[]
    having?: cardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }


  export type CardGroupByOutputType = {
    id: number
    match_id: number
    player_id: number
    card_type: string
    card_time: number
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type cardSelect = {
    id?: boolean
    match_id?: boolean
    player_id?: boolean
    card_type?: boolean
    card_time?: boolean
    match?: boolean | matchArgs
    player?: boolean | playerArgs
  }


  export type cardInclude = {
    match?: boolean | matchArgs
    player?: boolean | playerArgs
  }

  export type cardGetPayload<S extends boolean | null | undefined | cardArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? card :
    S extends undefined ? never :
    S extends { include: any } & (cardArgs | cardFindManyArgs)
    ? card  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'match' ? matchGetPayload<S['include'][P]> :
        P extends 'player' ? playerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (cardArgs | cardFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'match' ? matchGetPayload<S['select'][P]> :
        P extends 'player' ? playerGetPayload<S['select'][P]> :  P extends keyof card ? card[P] : never
  } 
      : card


  type cardCountArgs = 
    Omit<cardFindManyArgs, 'select' | 'include'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface cardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Card that matches the filter.
     * @param {cardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'card'> extends True ? Prisma__cardClient<cardGetPayload<T>> : Prisma__cardClient<cardGetPayload<T> | null, null>

    /**
     * Find one Card that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cardFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cardFindUniqueOrThrowArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'card'> extends True ? Prisma__cardClient<cardGetPayload<T>> : Prisma__cardClient<cardGetPayload<T> | null, null>

    /**
     * Find the first Card that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cardFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cardFindFirstOrThrowArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cardFindManyArgs>(
      args?: SelectSubset<T, cardFindManyArgs>
    ): Prisma.PrismaPromise<Array<cardGetPayload<T>>>

    /**
     * Create a Card.
     * @param {cardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
    **/
    create<T extends cardCreateArgs>(
      args: SelectSubset<T, cardCreateArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Create many Cards.
     *     @param {cardCreateManyArgs} args - Arguments to create many Cards.
     *     @example
     *     // Create many Cards
     *     const card = await prisma.card.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cardCreateManyArgs>(
      args?: SelectSubset<T, cardCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Card.
     * @param {cardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
    **/
    delete<T extends cardDeleteArgs>(
      args: SelectSubset<T, cardDeleteArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Update one Card.
     * @param {cardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cardUpdateArgs>(
      args: SelectSubset<T, cardUpdateArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Delete zero or more Cards.
     * @param {cardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cardDeleteManyArgs>(
      args?: SelectSubset<T, cardDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cardUpdateManyArgs>(
      args: SelectSubset<T, cardUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {cardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
    **/
    upsert<T extends cardUpsertArgs>(
      args: SelectSubset<T, cardUpsertArgs>
    ): Prisma__cardClient<cardGetPayload<T>>

    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends cardCountArgs>(
      args?: Subset<T, cardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cardClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    player<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * card base type for findUnique actions
   */
  export type cardFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     */
    where: cardWhereUniqueInput
  }

  /**
   * card findUnique
   */
  export interface cardFindUniqueArgs extends cardFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * card findUniqueOrThrow
   */
  export type cardFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     */
    where: cardWhereUniqueInput
  }


  /**
   * card base type for findFirst actions
   */
  export type cardFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     */
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     */
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cards.
     */
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cards.
     */
    distinct?: Enumerable<CardScalarFieldEnum>
  }

  /**
   * card findFirst
   */
  export interface cardFindFirstArgs extends cardFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * card findFirstOrThrow
   */
  export type cardFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter, which card to fetch.
     */
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     */
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cards.
     */
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cards.
     */
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * card findMany
   */
  export type cardFindManyArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter, which cards to fetch.
     */
    where?: cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cards to fetch.
     */
    orderBy?: Enumerable<cardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cards.
     */
    cursor?: cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cards.
     */
    skip?: number
    distinct?: Enumerable<CardScalarFieldEnum>
  }


  /**
   * card create
   */
  export type cardCreateArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * The data needed to create a card.
     */
    data: XOR<cardCreateInput, cardUncheckedCreateInput>
  }


  /**
   * card createMany
   */
  export type cardCreateManyArgs = {
    /**
     * The data used to create many cards.
     */
    data: Enumerable<cardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * card update
   */
  export type cardUpdateArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * The data needed to update a card.
     */
    data: XOR<cardUpdateInput, cardUncheckedUpdateInput>
    /**
     * Choose, which card to update.
     */
    where: cardWhereUniqueInput
  }


  /**
   * card updateMany
   */
  export type cardUpdateManyArgs = {
    /**
     * The data used to update cards.
     */
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyInput>
    /**
     * Filter which cards to update
     */
    where?: cardWhereInput
  }


  /**
   * card upsert
   */
  export type cardUpsertArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * The filter to search for the card to update in case it exists.
     */
    where: cardWhereUniqueInput
    /**
     * In case the card found by the `where` argument doesn't exist, create a new card with this data.
     */
    create: XOR<cardCreateInput, cardUncheckedCreateInput>
    /**
     * In case the card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cardUpdateInput, cardUncheckedUpdateInput>
  }


  /**
   * card delete
   */
  export type cardDeleteArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
    /**
     * Filter which card to delete.
     */
    where: cardWhereUniqueInput
  }


  /**
   * card deleteMany
   */
  export type cardDeleteManyArgs = {
    /**
     * Filter which cards to delete
     */
    where?: cardWhereInput
  }


  /**
   * card without action
   */
  export type cardArgs = {
    /**
     * Select specific fields to fetch from the card
     */
    select?: cardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cardInclude | null
  }



  /**
   * Model switchPlayer
   */


  export type AggregateSwitchPlayer = {
    _count: SwitchPlayerCountAggregateOutputType | null
    _avg: SwitchPlayerAvgAggregateOutputType | null
    _sum: SwitchPlayerSumAggregateOutputType | null
    _min: SwitchPlayerMinAggregateOutputType | null
    _max: SwitchPlayerMaxAggregateOutputType | null
  }

  export type SwitchPlayerAvgAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_out_id: number | null
    player_in_id: number | null
    switch_time: number | null
  }

  export type SwitchPlayerSumAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_out_id: number | null
    player_in_id: number | null
    switch_time: number | null
  }

  export type SwitchPlayerMinAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_out_id: number | null
    player_in_id: number | null
    switch_time: number | null
  }

  export type SwitchPlayerMaxAggregateOutputType = {
    id: number | null
    match_id: number | null
    player_out_id: number | null
    player_in_id: number | null
    switch_time: number | null
  }

  export type SwitchPlayerCountAggregateOutputType = {
    id: number
    match_id: number
    player_out_id: number
    player_in_id: number
    switch_time: number
    _all: number
  }


  export type SwitchPlayerAvgAggregateInputType = {
    id?: true
    match_id?: true
    player_out_id?: true
    player_in_id?: true
    switch_time?: true
  }

  export type SwitchPlayerSumAggregateInputType = {
    id?: true
    match_id?: true
    player_out_id?: true
    player_in_id?: true
    switch_time?: true
  }

  export type SwitchPlayerMinAggregateInputType = {
    id?: true
    match_id?: true
    player_out_id?: true
    player_in_id?: true
    switch_time?: true
  }

  export type SwitchPlayerMaxAggregateInputType = {
    id?: true
    match_id?: true
    player_out_id?: true
    player_in_id?: true
    switch_time?: true
  }

  export type SwitchPlayerCountAggregateInputType = {
    id?: true
    match_id?: true
    player_out_id?: true
    player_in_id?: true
    switch_time?: true
    _all?: true
  }

  export type SwitchPlayerAggregateArgs = {
    /**
     * Filter which switchPlayer to aggregate.
     */
    where?: switchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of switchPlayers to fetch.
     */
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: switchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` switchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` switchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned switchPlayers
    **/
    _count?: true | SwitchPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SwitchPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SwitchPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SwitchPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SwitchPlayerMaxAggregateInputType
  }

  export type GetSwitchPlayerAggregateType<T extends SwitchPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateSwitchPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSwitchPlayer[P]>
      : GetScalarType<T[P], AggregateSwitchPlayer[P]>
  }




  export type SwitchPlayerGroupByArgs = {
    where?: switchPlayerWhereInput
    orderBy?: Enumerable<switchPlayerOrderByWithAggregationInput>
    by: SwitchPlayerScalarFieldEnum[]
    having?: switchPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SwitchPlayerCountAggregateInputType | true
    _avg?: SwitchPlayerAvgAggregateInputType
    _sum?: SwitchPlayerSumAggregateInputType
    _min?: SwitchPlayerMinAggregateInputType
    _max?: SwitchPlayerMaxAggregateInputType
  }


  export type SwitchPlayerGroupByOutputType = {
    id: number
    match_id: number
    player_out_id: number
    player_in_id: number
    switch_time: number
    _count: SwitchPlayerCountAggregateOutputType | null
    _avg: SwitchPlayerAvgAggregateOutputType | null
    _sum: SwitchPlayerSumAggregateOutputType | null
    _min: SwitchPlayerMinAggregateOutputType | null
    _max: SwitchPlayerMaxAggregateOutputType | null
  }

  type GetSwitchPlayerGroupByPayload<T extends SwitchPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SwitchPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SwitchPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SwitchPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], SwitchPlayerGroupByOutputType[P]>
        }
      >
    >


  export type switchPlayerSelect = {
    id?: boolean
    match_id?: boolean
    player_out_id?: boolean
    player_in_id?: boolean
    switch_time?: boolean
    match?: boolean | matchArgs
    player_out?: boolean | playerArgs
    player_in?: boolean | playerArgs
  }


  export type switchPlayerInclude = {
    match?: boolean | matchArgs
    player_out?: boolean | playerArgs
    player_in?: boolean | playerArgs
  }

  export type switchPlayerGetPayload<S extends boolean | null | undefined | switchPlayerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? switchPlayer :
    S extends undefined ? never :
    S extends { include: any } & (switchPlayerArgs | switchPlayerFindManyArgs)
    ? switchPlayer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'match' ? matchGetPayload<S['include'][P]> :
        P extends 'player_out' ? playerGetPayload<S['include'][P]> :
        P extends 'player_in' ? playerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (switchPlayerArgs | switchPlayerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'match' ? matchGetPayload<S['select'][P]> :
        P extends 'player_out' ? playerGetPayload<S['select'][P]> :
        P extends 'player_in' ? playerGetPayload<S['select'][P]> :  P extends keyof switchPlayer ? switchPlayer[P] : never
  } 
      : switchPlayer


  type switchPlayerCountArgs = 
    Omit<switchPlayerFindManyArgs, 'select' | 'include'> & {
      select?: SwitchPlayerCountAggregateInputType | true
    }

  export interface switchPlayerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SwitchPlayer that matches the filter.
     * @param {switchPlayerFindUniqueArgs} args - Arguments to find a SwitchPlayer
     * @example
     * // Get one SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends switchPlayerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, switchPlayerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'switchPlayer'> extends True ? Prisma__switchPlayerClient<switchPlayerGetPayload<T>> : Prisma__switchPlayerClient<switchPlayerGetPayload<T> | null, null>

    /**
     * Find one SwitchPlayer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {switchPlayerFindUniqueOrThrowArgs} args - Arguments to find a SwitchPlayer
     * @example
     * // Get one SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends switchPlayerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, switchPlayerFindUniqueOrThrowArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Find the first SwitchPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {switchPlayerFindFirstArgs} args - Arguments to find a SwitchPlayer
     * @example
     * // Get one SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends switchPlayerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, switchPlayerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'switchPlayer'> extends True ? Prisma__switchPlayerClient<switchPlayerGetPayload<T>> : Prisma__switchPlayerClient<switchPlayerGetPayload<T> | null, null>

    /**
     * Find the first SwitchPlayer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {switchPlayerFindFirstOrThrowArgs} args - Arguments to find a SwitchPlayer
     * @example
     * // Get one SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends switchPlayerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, switchPlayerFindFirstOrThrowArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Find zero or more SwitchPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {switchPlayerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SwitchPlayers
     * const switchPlayers = await prisma.switchPlayer.findMany()
     * 
     * // Get first 10 SwitchPlayers
     * const switchPlayers = await prisma.switchPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const switchPlayerWithIdOnly = await prisma.switchPlayer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends switchPlayerFindManyArgs>(
      args?: SelectSubset<T, switchPlayerFindManyArgs>
    ): Prisma.PrismaPromise<Array<switchPlayerGetPayload<T>>>

    /**
     * Create a SwitchPlayer.
     * @param {switchPlayerCreateArgs} args - Arguments to create a SwitchPlayer.
     * @example
     * // Create one SwitchPlayer
     * const SwitchPlayer = await prisma.switchPlayer.create({
     *   data: {
     *     // ... data to create a SwitchPlayer
     *   }
     * })
     * 
    **/
    create<T extends switchPlayerCreateArgs>(
      args: SelectSubset<T, switchPlayerCreateArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Create many SwitchPlayers.
     *     @param {switchPlayerCreateManyArgs} args - Arguments to create many SwitchPlayers.
     *     @example
     *     // Create many SwitchPlayers
     *     const switchPlayer = await prisma.switchPlayer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends switchPlayerCreateManyArgs>(
      args?: SelectSubset<T, switchPlayerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SwitchPlayer.
     * @param {switchPlayerDeleteArgs} args - Arguments to delete one SwitchPlayer.
     * @example
     * // Delete one SwitchPlayer
     * const SwitchPlayer = await prisma.switchPlayer.delete({
     *   where: {
     *     // ... filter to delete one SwitchPlayer
     *   }
     * })
     * 
    **/
    delete<T extends switchPlayerDeleteArgs>(
      args: SelectSubset<T, switchPlayerDeleteArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Update one SwitchPlayer.
     * @param {switchPlayerUpdateArgs} args - Arguments to update one SwitchPlayer.
     * @example
     * // Update one SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends switchPlayerUpdateArgs>(
      args: SelectSubset<T, switchPlayerUpdateArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Delete zero or more SwitchPlayers.
     * @param {switchPlayerDeleteManyArgs} args - Arguments to filter SwitchPlayers to delete.
     * @example
     * // Delete a few SwitchPlayers
     * const { count } = await prisma.switchPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends switchPlayerDeleteManyArgs>(
      args?: SelectSubset<T, switchPlayerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SwitchPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {switchPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SwitchPlayers
     * const switchPlayer = await prisma.switchPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends switchPlayerUpdateManyArgs>(
      args: SelectSubset<T, switchPlayerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SwitchPlayer.
     * @param {switchPlayerUpsertArgs} args - Arguments to update or create a SwitchPlayer.
     * @example
     * // Update or create a SwitchPlayer
     * const switchPlayer = await prisma.switchPlayer.upsert({
     *   create: {
     *     // ... data to create a SwitchPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SwitchPlayer we want to update
     *   }
     * })
    **/
    upsert<T extends switchPlayerUpsertArgs>(
      args: SelectSubset<T, switchPlayerUpsertArgs>
    ): Prisma__switchPlayerClient<switchPlayerGetPayload<T>>

    /**
     * Count the number of SwitchPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {switchPlayerCountArgs} args - Arguments to filter SwitchPlayers to count.
     * @example
     * // Count the number of SwitchPlayers
     * const count = await prisma.switchPlayer.count({
     *   where: {
     *     // ... the filter for the SwitchPlayers we want to count
     *   }
     * })
    **/
    count<T extends switchPlayerCountArgs>(
      args?: Subset<T, switchPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SwitchPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SwitchPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SwitchPlayerAggregateArgs>(args: Subset<T, SwitchPlayerAggregateArgs>): Prisma.PrismaPromise<GetSwitchPlayerAggregateType<T>>

    /**
     * Group by SwitchPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SwitchPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SwitchPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SwitchPlayerGroupByArgs['orderBy'] }
        : { orderBy?: SwitchPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SwitchPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSwitchPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for switchPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__switchPlayerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    match<T extends matchArgs= {}>(args?: Subset<T, matchArgs>): Prisma__matchClient<matchGetPayload<T> | Null>;

    player_out<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    player_in<T extends playerArgs= {}>(args?: Subset<T, playerArgs>): Prisma__playerClient<playerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * switchPlayer base type for findUnique actions
   */
  export type switchPlayerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter, which switchPlayer to fetch.
     */
    where: switchPlayerWhereUniqueInput
  }

  /**
   * switchPlayer findUnique
   */
  export interface switchPlayerFindUniqueArgs extends switchPlayerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * switchPlayer findUniqueOrThrow
   */
  export type switchPlayerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter, which switchPlayer to fetch.
     */
    where: switchPlayerWhereUniqueInput
  }


  /**
   * switchPlayer base type for findFirst actions
   */
  export type switchPlayerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter, which switchPlayer to fetch.
     */
    where?: switchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of switchPlayers to fetch.
     */
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for switchPlayers.
     */
    cursor?: switchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` switchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` switchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of switchPlayers.
     */
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }

  /**
   * switchPlayer findFirst
   */
  export interface switchPlayerFindFirstArgs extends switchPlayerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * switchPlayer findFirstOrThrow
   */
  export type switchPlayerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter, which switchPlayer to fetch.
     */
    where?: switchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of switchPlayers to fetch.
     */
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for switchPlayers.
     */
    cursor?: switchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` switchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` switchPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of switchPlayers.
     */
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }


  /**
   * switchPlayer findMany
   */
  export type switchPlayerFindManyArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter, which switchPlayers to fetch.
     */
    where?: switchPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of switchPlayers to fetch.
     */
    orderBy?: Enumerable<switchPlayerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing switchPlayers.
     */
    cursor?: switchPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` switchPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` switchPlayers.
     */
    skip?: number
    distinct?: Enumerable<SwitchPlayerScalarFieldEnum>
  }


  /**
   * switchPlayer create
   */
  export type switchPlayerCreateArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * The data needed to create a switchPlayer.
     */
    data: XOR<switchPlayerCreateInput, switchPlayerUncheckedCreateInput>
  }


  /**
   * switchPlayer createMany
   */
  export type switchPlayerCreateManyArgs = {
    /**
     * The data used to create many switchPlayers.
     */
    data: Enumerable<switchPlayerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * switchPlayer update
   */
  export type switchPlayerUpdateArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * The data needed to update a switchPlayer.
     */
    data: XOR<switchPlayerUpdateInput, switchPlayerUncheckedUpdateInput>
    /**
     * Choose, which switchPlayer to update.
     */
    where: switchPlayerWhereUniqueInput
  }


  /**
   * switchPlayer updateMany
   */
  export type switchPlayerUpdateManyArgs = {
    /**
     * The data used to update switchPlayers.
     */
    data: XOR<switchPlayerUpdateManyMutationInput, switchPlayerUncheckedUpdateManyInput>
    /**
     * Filter which switchPlayers to update
     */
    where?: switchPlayerWhereInput
  }


  /**
   * switchPlayer upsert
   */
  export type switchPlayerUpsertArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * The filter to search for the switchPlayer to update in case it exists.
     */
    where: switchPlayerWhereUniqueInput
    /**
     * In case the switchPlayer found by the `where` argument doesn't exist, create a new switchPlayer with this data.
     */
    create: XOR<switchPlayerCreateInput, switchPlayerUncheckedCreateInput>
    /**
     * In case the switchPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<switchPlayerUpdateInput, switchPlayerUncheckedUpdateInput>
  }


  /**
   * switchPlayer delete
   */
  export type switchPlayerDeleteArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
    /**
     * Filter which switchPlayer to delete.
     */
    where: switchPlayerWhereUniqueInput
  }


  /**
   * switchPlayer deleteMany
   */
  export type switchPlayerDeleteManyArgs = {
    /**
     * Filter which switchPlayers to delete
     */
    where?: switchPlayerWhereInput
  }


  /**
   * switchPlayer without action
   */
  export type switchPlayerArgs = {
    /**
     * Select specific fields to fetch from the switchPlayer
     */
    select?: switchPlayerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: switchPlayerInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BallPossessionScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    team_id: 'team_id',
    possession_time: 'possession_time'
  };

  export type BallPossessionScalarFieldEnum = (typeof BallPossessionScalarFieldEnum)[keyof typeof BallPossessionScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    player_id: 'player_id',
    card_type: 'card_type',
    card_time: 'card_time'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const FoulScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    team_id: 'team_id',
    player_id: 'player_id',
    type: 'type'
  };

  export type FoulScalarFieldEnum = (typeof FoulScalarFieldEnum)[keyof typeof FoulScalarFieldEnum]


  export const GoalScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    player_id: 'player_id',
    goal_time: 'goal_time'
  };

  export type GoalScalarFieldEnum = (typeof GoalScalarFieldEnum)[keyof typeof GoalScalarFieldEnum]


  export const InjuryScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    player_id: 'player_id',
    injury_type: 'injury_type'
  };

  export type InjuryScalarFieldEnum = (typeof InjuryScalarFieldEnum)[keyof typeof InjuryScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    homeTeam: 'homeTeam',
    awayTeam: 'awayTeam'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const OffsetScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    offset_team_id: 'offset_team_id',
    offset_time: 'offset_time'
  };

  export type OffsetScalarFieldEnum = (typeof OffsetScalarFieldEnum)[keyof typeof OffsetScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    numberJersey: 'numberJersey',
    position: 'position',
    status: 'status',
    team_id: 'team_id'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SwitchPlayerScalarFieldEnum: {
    id: 'id',
    match_id: 'match_id',
    player_out_id: 'player_out_id',
    player_in_id: 'player_in_id',
    switch_time: 'switch_time'
  };

  export type SwitchPlayerScalarFieldEnum = (typeof SwitchPlayerScalarFieldEnum)[keyof typeof SwitchPlayerScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logo: 'logo'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type playerWhereInput = {
    AND?: Enumerable<playerWhereInput>
    OR?: Enumerable<playerWhereInput>
    NOT?: Enumerable<playerWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    numberJersey?: StringFilter | string
    position?: StringFilter | string
    status?: EnumStatusFilter | Status
    team_id?: IntFilter | number
    goals?: GoalListRelationFilter
    injurys?: InjuryListRelationFilter
    fouls?: FoulListRelationFilter
    cards?: CardListRelationFilter
    team?: XOR<TeamRelationFilter, teamWhereInput>
    switchPlayerOut?: SwitchPlayerListRelationFilter
    switchPlayerIn?: SwitchPlayerListRelationFilter
  }

  export type playerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    numberJersey?: SortOrder
    position?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    goals?: goalOrderByRelationAggregateInput
    injurys?: injuryOrderByRelationAggregateInput
    fouls?: foulOrderByRelationAggregateInput
    cards?: cardOrderByRelationAggregateInput
    team?: teamOrderByWithRelationInput
    switchPlayerOut?: switchPlayerOrderByRelationAggregateInput
    switchPlayerIn?: switchPlayerOrderByRelationAggregateInput
  }

  export type playerWhereUniqueInput = {
    id?: number
  }

  export type playerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    numberJersey?: SortOrder
    position?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
    _count?: playerCountOrderByAggregateInput
    _avg?: playerAvgOrderByAggregateInput
    _max?: playerMaxOrderByAggregateInput
    _min?: playerMinOrderByAggregateInput
    _sum?: playerSumOrderByAggregateInput
  }

  export type playerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<playerScalarWhereWithAggregatesInput>
    OR?: Enumerable<playerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<playerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    numberJersey?: StringWithAggregatesFilter | string
    position?: StringWithAggregatesFilter | string
    status?: EnumStatusWithAggregatesFilter | Status
    team_id?: IntWithAggregatesFilter | number
  }

  export type teamWhereInput = {
    AND?: Enumerable<teamWhereInput>
    OR?: Enumerable<teamWhereInput>
    NOT?: Enumerable<teamWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    logo?: StringFilter | string
    match1?: MatchListRelationFilter
    match2?: MatchListRelationFilter
    player?: PlayerListRelationFilter
    offset?: OffsetListRelationFilter
    ballPossession?: BallPossessionListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    match1?: matchOrderByRelationAggregateInput
    match2?: matchOrderByRelationAggregateInput
    player?: playerOrderByRelationAggregateInput
    offset?: offsetOrderByRelationAggregateInput
    ballPossession?: ballPossessionOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = {
    id?: number
  }

  export type teamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: Enumerable<teamScalarWhereWithAggregatesInput>
    OR?: Enumerable<teamScalarWhereWithAggregatesInput>
    NOT?: Enumerable<teamScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    logo?: StringWithAggregatesFilter | string
  }

  export type matchWhereInput = {
    AND?: Enumerable<matchWhereInput>
    OR?: Enumerable<matchWhereInput>
    NOT?: Enumerable<matchWhereInput>
    id?: IntFilter | number
    homeTeam?: IntFilter | number
    awayTeam?: IntFilter | number
    home_team?: XOR<TeamRelationFilter, teamWhereInput>
    away_team?: XOR<TeamRelationFilter, teamWhereInput>
    offset?: OffsetListRelationFilter
    goal?: GoalListRelationFilter
    foul?: FoulListRelationFilter
    injury?: InjuryListRelationFilter
    ballPossession?: BallPossessionListRelationFilter
    card?: CardListRelationFilter
    switchPlayer?: SwitchPlayerListRelationFilter
  }

  export type matchOrderByWithRelationInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    home_team?: teamOrderByWithRelationInput
    away_team?: teamOrderByWithRelationInput
    offset?: offsetOrderByRelationAggregateInput
    goal?: goalOrderByRelationAggregateInput
    foul?: foulOrderByRelationAggregateInput
    injury?: injuryOrderByRelationAggregateInput
    ballPossession?: ballPossessionOrderByRelationAggregateInput
    card?: cardOrderByRelationAggregateInput
    switchPlayer?: switchPlayerOrderByRelationAggregateInput
  }

  export type matchWhereUniqueInput = {
    id?: number
  }

  export type matchOrderByWithAggregationInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
    _count?: matchCountOrderByAggregateInput
    _avg?: matchAvgOrderByAggregateInput
    _max?: matchMaxOrderByAggregateInput
    _min?: matchMinOrderByAggregateInput
    _sum?: matchSumOrderByAggregateInput
  }

  export type matchScalarWhereWithAggregatesInput = {
    AND?: Enumerable<matchScalarWhereWithAggregatesInput>
    OR?: Enumerable<matchScalarWhereWithAggregatesInput>
    NOT?: Enumerable<matchScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    homeTeam?: IntWithAggregatesFilter | number
    awayTeam?: IntWithAggregatesFilter | number
  }

  export type offsetWhereInput = {
    AND?: Enumerable<offsetWhereInput>
    OR?: Enumerable<offsetWhereInput>
    NOT?: Enumerable<offsetWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    offset_team_id?: IntFilter | number
    offset_time?: IntFilter | number
    match?: XOR<MatchRelationFilter, matchWhereInput>
    offset_team?: XOR<TeamRelationFilter, teamWhereInput>
  }

  export type offsetOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
    match?: matchOrderByWithRelationInput
    offset_team?: teamOrderByWithRelationInput
  }

  export type offsetWhereUniqueInput = {
    id?: number
  }

  export type offsetOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
    _count?: offsetCountOrderByAggregateInput
    _avg?: offsetAvgOrderByAggregateInput
    _max?: offsetMaxOrderByAggregateInput
    _min?: offsetMinOrderByAggregateInput
    _sum?: offsetSumOrderByAggregateInput
  }

  export type offsetScalarWhereWithAggregatesInput = {
    AND?: Enumerable<offsetScalarWhereWithAggregatesInput>
    OR?: Enumerable<offsetScalarWhereWithAggregatesInput>
    NOT?: Enumerable<offsetScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    offset_team_id?: IntWithAggregatesFilter | number
    offset_time?: IntWithAggregatesFilter | number
  }

  export type goalWhereInput = {
    AND?: Enumerable<goalWhereInput>
    OR?: Enumerable<goalWhereInput>
    NOT?: Enumerable<goalWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    goal_time?: IntFilter | number
    player?: XOR<PlayerRelationFilter, playerWhereInput>
    match?: XOR<MatchRelationFilter, matchWhereInput>
  }

  export type goalOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
    player?: playerOrderByWithRelationInput
    match?: matchOrderByWithRelationInput
  }

  export type goalWhereUniqueInput = {
    id?: number
  }

  export type goalOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
    _count?: goalCountOrderByAggregateInput
    _avg?: goalAvgOrderByAggregateInput
    _max?: goalMaxOrderByAggregateInput
    _min?: goalMinOrderByAggregateInput
    _sum?: goalSumOrderByAggregateInput
  }

  export type goalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<goalScalarWhereWithAggregatesInput>
    OR?: Enumerable<goalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<goalScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    goal_time?: IntWithAggregatesFilter | number
  }

  export type foulWhereInput = {
    AND?: Enumerable<foulWhereInput>
    OR?: Enumerable<foulWhereInput>
    NOT?: Enumerable<foulWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    team_id?: IntFilter | number
    player_id?: IntFilter | number
    type?: StringNullableFilter | string | null
    player?: XOR<PlayerRelationFilter, playerWhereInput>
    match?: XOR<MatchRelationFilter, matchWhereInput>
  }

  export type foulOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    player?: playerOrderByWithRelationInput
    match?: matchOrderByWithRelationInput
  }

  export type foulWhereUniqueInput = {
    id?: number
  }

  export type foulOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
    _count?: foulCountOrderByAggregateInput
    _avg?: foulAvgOrderByAggregateInput
    _max?: foulMaxOrderByAggregateInput
    _min?: foulMinOrderByAggregateInput
    _sum?: foulSumOrderByAggregateInput
  }

  export type foulScalarWhereWithAggregatesInput = {
    AND?: Enumerable<foulScalarWhereWithAggregatesInput>
    OR?: Enumerable<foulScalarWhereWithAggregatesInput>
    NOT?: Enumerable<foulScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    team_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    type?: StringNullableWithAggregatesFilter | string | null
  }

  export type injuryWhereInput = {
    AND?: Enumerable<injuryWhereInput>
    OR?: Enumerable<injuryWhereInput>
    NOT?: Enumerable<injuryWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    injury_type?: StringFilter | string
    player?: XOR<PlayerRelationFilter, playerWhereInput>
    match?: XOR<MatchRelationFilter, matchWhereInput>
  }

  export type injuryOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    injury_type?: SortOrder
    player?: playerOrderByWithRelationInput
    match?: matchOrderByWithRelationInput
  }

  export type injuryWhereUniqueInput = {
    id?: number
  }

  export type injuryOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    injury_type?: SortOrder
    _count?: injuryCountOrderByAggregateInput
    _avg?: injuryAvgOrderByAggregateInput
    _max?: injuryMaxOrderByAggregateInput
    _min?: injuryMinOrderByAggregateInput
    _sum?: injurySumOrderByAggregateInput
  }

  export type injuryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<injuryScalarWhereWithAggregatesInput>
    OR?: Enumerable<injuryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<injuryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    injury_type?: StringWithAggregatesFilter | string
  }

  export type ballPossessionWhereInput = {
    AND?: Enumerable<ballPossessionWhereInput>
    OR?: Enumerable<ballPossessionWhereInput>
    NOT?: Enumerable<ballPossessionWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    team_id?: IntFilter | number
    possession_time?: FloatFilter | number
    match?: XOR<MatchRelationFilter, matchWhereInput>
    team?: XOR<TeamRelationFilter, teamWhereInput>
  }

  export type ballPossessionOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
    match?: matchOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type ballPossessionWhereUniqueInput = {
    id?: number
  }

  export type ballPossessionOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
    _count?: ballPossessionCountOrderByAggregateInput
    _avg?: ballPossessionAvgOrderByAggregateInput
    _max?: ballPossessionMaxOrderByAggregateInput
    _min?: ballPossessionMinOrderByAggregateInput
    _sum?: ballPossessionSumOrderByAggregateInput
  }

  export type ballPossessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ballPossessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<ballPossessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ballPossessionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    team_id?: IntWithAggregatesFilter | number
    possession_time?: FloatWithAggregatesFilter | number
  }

  export type cardWhereInput = {
    AND?: Enumerable<cardWhereInput>
    OR?: Enumerable<cardWhereInput>
    NOT?: Enumerable<cardWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    card_type?: StringFilter | string
    card_time?: IntFilter | number
    match?: XOR<MatchRelationFilter, matchWhereInput>
    player?: XOR<PlayerRelationFilter, playerWhereInput>
  }

  export type cardOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_type?: SortOrder
    card_time?: SortOrder
    match?: matchOrderByWithRelationInput
    player?: playerOrderByWithRelationInput
  }

  export type cardWhereUniqueInput = {
    id?: number
  }

  export type cardOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_type?: SortOrder
    card_time?: SortOrder
    _count?: cardCountOrderByAggregateInput
    _avg?: cardAvgOrderByAggregateInput
    _max?: cardMaxOrderByAggregateInput
    _min?: cardMinOrderByAggregateInput
    _sum?: cardSumOrderByAggregateInput
  }

  export type cardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cardScalarWhereWithAggregatesInput>
    OR?: Enumerable<cardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    player_id?: IntWithAggregatesFilter | number
    card_type?: StringWithAggregatesFilter | string
    card_time?: IntWithAggregatesFilter | number
  }

  export type switchPlayerWhereInput = {
    AND?: Enumerable<switchPlayerWhereInput>
    OR?: Enumerable<switchPlayerWhereInput>
    NOT?: Enumerable<switchPlayerWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_out_id?: IntFilter | number
    player_in_id?: IntFilter | number
    switch_time?: IntFilter | number
    match?: XOR<MatchRelationFilter, matchWhereInput>
    player_out?: XOR<PlayerRelationFilter, playerWhereInput>
    player_in?: XOR<PlayerRelationFilter, playerWhereInput>
  }

  export type switchPlayerOrderByWithRelationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
    match?: matchOrderByWithRelationInput
    player_out?: playerOrderByWithRelationInput
    player_in?: playerOrderByWithRelationInput
  }

  export type switchPlayerWhereUniqueInput = {
    id?: number
  }

  export type switchPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
    _count?: switchPlayerCountOrderByAggregateInput
    _avg?: switchPlayerAvgOrderByAggregateInput
    _max?: switchPlayerMaxOrderByAggregateInput
    _min?: switchPlayerMinOrderByAggregateInput
    _sum?: switchPlayerSumOrderByAggregateInput
  }

  export type switchPlayerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<switchPlayerScalarWhereWithAggregatesInput>
    OR?: Enumerable<switchPlayerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<switchPlayerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    match_id?: IntWithAggregatesFilter | number
    player_out_id?: IntWithAggregatesFilter | number
    player_in_id?: IntWithAggregatesFilter | number
    switch_time?: IntWithAggregatesFilter | number
  }

  export type playerCreateInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerCreateManyInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
  }

  export type playerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
  }

  export type playerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
  }

  export type teamCreateInput = {
    name: string
    logo: string
    match1?: matchCreateNestedManyWithoutHome_teamInput
    match2?: matchCreateNestedManyWithoutAway_teamInput
    player?: playerCreateNestedManyWithoutTeamInput
    offset?: offsetCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    id?: number
    name: string
    logo: string
    match1?: matchUncheckedCreateNestedManyWithoutHome_teamInput
    match2?: matchUncheckedCreateNestedManyWithoutAway_teamInput
    player?: playerUncheckedCreateNestedManyWithoutTeamInput
    offset?: offsetUncheckedCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUpdateManyWithoutHome_teamNestedInput
    match2?: matchUpdateManyWithoutAway_teamNestedInput
    player?: playerUpdateManyWithoutTeamNestedInput
    offset?: offsetUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUncheckedUpdateManyWithoutHome_teamNestedInput
    match2?: matchUncheckedUpdateManyWithoutAway_teamNestedInput
    player?: playerUncheckedUpdateManyWithoutTeamNestedInput
    offset?: offsetUncheckedUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateManyInput = {
    id?: number
    name: string
    logo: string
  }

  export type teamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
  }

  export type teamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
  }

  export type matchCreateInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchUpdateInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type matchCreateManyInput = {
    id?: number
    homeTeam: number
    awayTeam: number
  }

  export type matchUpdateManyMutationInput = {

  }

  export type matchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
  }

  export type offsetCreateInput = {
    offset_time: number
    match: matchCreateNestedOneWithoutOffsetInput
    offset_team: teamCreateNestedOneWithoutOffsetInput
  }

  export type offsetUncheckedCreateInput = {
    id?: number
    match_id: number
    offset_team_id: number
    offset_time: number
  }

  export type offsetUpdateInput = {
    offset_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutOffsetNestedInput
    offset_team?: teamUpdateOneRequiredWithoutOffsetNestedInput
  }

  export type offsetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    offset_team_id?: IntFieldUpdateOperationsInput | number
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type offsetCreateManyInput = {
    id?: number
    match_id: number
    offset_team_id: number
    offset_time: number
  }

  export type offsetUpdateManyMutationInput = {
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type offsetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    offset_team_id?: IntFieldUpdateOperationsInput | number
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalCreateInput = {
    goal_time: number
    player: playerCreateNestedOneWithoutGoalsInput
    match: matchCreateNestedOneWithoutGoalInput
  }

  export type goalUncheckedCreateInput = {
    id?: number
    match_id: number
    player_id: number
    goal_time: number
  }

  export type goalUpdateInput = {
    goal_time?: IntFieldUpdateOperationsInput | number
    player?: playerUpdateOneRequiredWithoutGoalsNestedInput
    match?: matchUpdateOneRequiredWithoutGoalNestedInput
  }

  export type goalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalCreateManyInput = {
    id?: number
    match_id: number
    player_id: number
    goal_time: number
  }

  export type goalUpdateManyMutationInput = {
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type foulCreateInput = {
    team_id: number
    type?: string | null
    player: playerCreateNestedOneWithoutFoulsInput
    match: matchCreateNestedOneWithoutFoulInput
  }

  export type foulUncheckedCreateInput = {
    id?: number
    match_id: number
    team_id: number
    player_id: number
    type?: string | null
  }

  export type foulUpdateInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    player?: playerUpdateOneRequiredWithoutFoulsNestedInput
    match?: matchUpdateOneRequiredWithoutFoulNestedInput
  }

  export type foulUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foulCreateManyInput = {
    id?: number
    match_id: number
    team_id: number
    player_id: number
    type?: string | null
  }

  export type foulUpdateManyMutationInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foulUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injuryCreateInput = {
    injury_type: string
    player: playerCreateNestedOneWithoutInjurysInput
    match: matchCreateNestedOneWithoutInjuryInput
  }

  export type injuryUncheckedCreateInput = {
    id?: number
    match_id: number
    player_id: number
    injury_type: string
  }

  export type injuryUpdateInput = {
    injury_type?: StringFieldUpdateOperationsInput | string
    player?: playerUpdateOneRequiredWithoutInjurysNestedInput
    match?: matchUpdateOneRequiredWithoutInjuryNestedInput
  }

  export type injuryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type injuryCreateManyInput = {
    id?: number
    match_id: number
    player_id: number
    injury_type: string
  }

  export type injuryUpdateManyMutationInput = {
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type injuryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type ballPossessionCreateInput = {
    possession_time: number
    match: matchCreateNestedOneWithoutBallPossessionInput
    team: teamCreateNestedOneWithoutBallPossessionInput
  }

  export type ballPossessionUncheckedCreateInput = {
    id?: number
    match_id: number
    team_id: number
    possession_time: number
  }

  export type ballPossessionUpdateInput = {
    possession_time?: FloatFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutBallPossessionNestedInput
    team?: teamUpdateOneRequiredWithoutBallPossessionNestedInput
  }

  export type ballPossessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type ballPossessionCreateManyInput = {
    id?: number
    match_id: number
    team_id: number
    possession_time: number
  }

  export type ballPossessionUpdateManyMutationInput = {
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type ballPossessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type cardCreateInput = {
    card_type: string
    card_time: number
    match: matchCreateNestedOneWithoutCardInput
    player: playerCreateNestedOneWithoutCardsInput
  }

  export type cardUncheckedCreateInput = {
    id?: number
    match_id: number
    player_id: number
    card_type: string
    card_time: number
  }

  export type cardUpdateInput = {
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutCardNestedInput
    player?: playerUpdateOneRequiredWithoutCardsNestedInput
  }

  export type cardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type cardCreateManyInput = {
    id?: number
    match_id: number
    player_id: number
    card_type: string
    card_time: number
  }

  export type cardUpdateManyMutationInput = {
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerCreateInput = {
    switch_time: number
    match: matchCreateNestedOneWithoutSwitchPlayerInput
    player_out: playerCreateNestedOneWithoutSwitchPlayerOutInput
    player_in: playerCreateNestedOneWithoutSwitchPlayerInInput
  }

  export type switchPlayerUncheckedCreateInput = {
    id?: number
    match_id: number
    player_out_id: number
    player_in_id: number
    switch_time: number
  }

  export type switchPlayerUpdateInput = {
    switch_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutSwitchPlayerNestedInput
    player_out?: playerUpdateOneRequiredWithoutSwitchPlayerOutNestedInput
    player_in?: playerUpdateOneRequiredWithoutSwitchPlayerInNestedInput
  }

  export type switchPlayerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerCreateManyInput = {
    id?: number
    match_id: number
    player_out_id: number
    player_in_id: number
    switch_time: number
  }

  export type switchPlayerUpdateManyMutationInput = {
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type EnumStatusFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusFilter | Status
  }

  export type GoalListRelationFilter = {
    every?: goalWhereInput
    some?: goalWhereInput
    none?: goalWhereInput
  }

  export type InjuryListRelationFilter = {
    every?: injuryWhereInput
    some?: injuryWhereInput
    none?: injuryWhereInput
  }

  export type FoulListRelationFilter = {
    every?: foulWhereInput
    some?: foulWhereInput
    none?: foulWhereInput
  }

  export type CardListRelationFilter = {
    every?: cardWhereInput
    some?: cardWhereInput
    none?: cardWhereInput
  }

  export type TeamRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type SwitchPlayerListRelationFilter = {
    every?: switchPlayerWhereInput
    some?: switchPlayerWhereInput
    none?: switchPlayerWhereInput
  }

  export type goalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type injuryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type foulOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type switchPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type playerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberJersey?: SortOrder
    position?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
  }

  export type playerAvgOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
  }

  export type playerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberJersey?: SortOrder
    position?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
  }

  export type playerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    numberJersey?: SortOrder
    position?: SortOrder
    status?: SortOrder
    team_id?: SortOrder
  }

  export type playerSumOrderByAggregateInput = {
    id?: SortOrder
    team_id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumStatusWithAggregatesFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusWithAggregatesFilter | Status
    _count?: NestedIntFilter
    _min?: NestedEnumStatusFilter
    _max?: NestedEnumStatusFilter
  }

  export type MatchListRelationFilter = {
    every?: matchWhereInput
    some?: matchWhereInput
    none?: matchWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: playerWhereInput
    some?: playerWhereInput
    none?: playerWhereInput
  }

  export type OffsetListRelationFilter = {
    every?: offsetWhereInput
    some?: offsetWhereInput
    none?: offsetWhereInput
  }

  export type BallPossessionListRelationFilter = {
    every?: ballPossessionWhereInput
    some?: ballPossessionWhereInput
    none?: ballPossessionWhereInput
  }

  export type matchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type playerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type offsetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ballPossessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logo?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type matchCountOrderByAggregateInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
  }

  export type matchAvgOrderByAggregateInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
  }

  export type matchMaxOrderByAggregateInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
  }

  export type matchMinOrderByAggregateInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
  }

  export type matchSumOrderByAggregateInput = {
    id?: SortOrder
    homeTeam?: SortOrder
    awayTeam?: SortOrder
  }

  export type MatchRelationFilter = {
    is?: matchWhereInput
    isNot?: matchWhereInput
  }

  export type offsetCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
  }

  export type offsetAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
  }

  export type offsetMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
  }

  export type offsetMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
  }

  export type offsetSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    offset_team_id?: SortOrder
    offset_time?: SortOrder
  }

  export type PlayerRelationFilter = {
    is?: playerWhereInput
    isNot?: playerWhereInput
  }

  export type goalCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
  }

  export type goalAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
  }

  export type goalMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
  }

  export type goalMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
  }

  export type goalSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    goal_time?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type foulCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
  }

  export type foulAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type foulMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
  }

  export type foulMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
    type?: SortOrder
  }

  export type foulSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    player_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type injuryCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    injury_type?: SortOrder
  }

  export type injuryAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
  }

  export type injuryMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    injury_type?: SortOrder
  }

  export type injuryMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    injury_type?: SortOrder
  }

  export type injurySumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type ballPossessionCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
  }

  export type ballPossessionAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
  }

  export type ballPossessionMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
  }

  export type ballPossessionMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
  }

  export type ballPossessionSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    team_id?: SortOrder
    possession_time?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type cardCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_type?: SortOrder
    card_time?: SortOrder
  }

  export type cardAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_time?: SortOrder
  }

  export type cardMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_type?: SortOrder
    card_time?: SortOrder
  }

  export type cardMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_type?: SortOrder
    card_time?: SortOrder
  }

  export type cardSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_id?: SortOrder
    card_time?: SortOrder
  }

  export type switchPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
  }

  export type switchPlayerAvgOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
  }

  export type switchPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
  }

  export type switchPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
  }

  export type switchPlayerSumOrderByAggregateInput = {
    id?: SortOrder
    match_id?: SortOrder
    player_out_id?: SortOrder
    player_in_id?: SortOrder
    switch_time?: SortOrder
  }

  export type goalCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<goalCreateWithoutPlayerInput>, Enumerable<goalUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutPlayerInput>
    createMany?: goalCreateManyPlayerInputEnvelope
    connect?: Enumerable<goalWhereUniqueInput>
  }

  export type injuryCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<injuryCreateWithoutPlayerInput>, Enumerable<injuryUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutPlayerInput>
    createMany?: injuryCreateManyPlayerInputEnvelope
    connect?: Enumerable<injuryWhereUniqueInput>
  }

  export type foulCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<foulCreateWithoutPlayerInput>, Enumerable<foulUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutPlayerInput>
    createMany?: foulCreateManyPlayerInputEnvelope
    connect?: Enumerable<foulWhereUniqueInput>
  }

  export type cardCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<cardCreateWithoutPlayerInput>, Enumerable<cardUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutPlayerInput>
    createMany?: cardCreateManyPlayerInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type teamCreateNestedOneWithoutPlayerInput = {
    create?: XOR<teamCreateWithoutPlayerInput, teamUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: teamCreateOrConnectWithoutPlayerInput
    connect?: teamWhereUniqueInput
  }

  export type switchPlayerCreateNestedManyWithoutPlayer_outInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_outInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_outInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_outInput>
    createMany?: switchPlayerCreateManyPlayer_outInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type switchPlayerCreateNestedManyWithoutPlayer_inInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_inInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_inInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_inInput>
    createMany?: switchPlayerCreateManyPlayer_inInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type goalUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<goalCreateWithoutPlayerInput>, Enumerable<goalUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutPlayerInput>
    createMany?: goalCreateManyPlayerInputEnvelope
    connect?: Enumerable<goalWhereUniqueInput>
  }

  export type injuryUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<injuryCreateWithoutPlayerInput>, Enumerable<injuryUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutPlayerInput>
    createMany?: injuryCreateManyPlayerInputEnvelope
    connect?: Enumerable<injuryWhereUniqueInput>
  }

  export type foulUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<foulCreateWithoutPlayerInput>, Enumerable<foulUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutPlayerInput>
    createMany?: foulCreateManyPlayerInputEnvelope
    connect?: Enumerable<foulWhereUniqueInput>
  }

  export type cardUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<Enumerable<cardCreateWithoutPlayerInput>, Enumerable<cardUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutPlayerInput>
    createMany?: cardCreateManyPlayerInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_outInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_outInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_outInput>
    createMany?: switchPlayerCreateManyPlayer_outInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_inInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_inInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_inInput>
    createMany?: switchPlayerCreateManyPlayer_inInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: Status
  }

  export type goalUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<goalCreateWithoutPlayerInput>, Enumerable<goalUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<goalUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: goalCreateManyPlayerInputEnvelope
    set?: Enumerable<goalWhereUniqueInput>
    disconnect?: Enumerable<goalWhereUniqueInput>
    delete?: Enumerable<goalWhereUniqueInput>
    connect?: Enumerable<goalWhereUniqueInput>
    update?: Enumerable<goalUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<goalUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<goalScalarWhereInput>
  }

  export type injuryUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<injuryCreateWithoutPlayerInput>, Enumerable<injuryUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<injuryUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: injuryCreateManyPlayerInputEnvelope
    set?: Enumerable<injuryWhereUniqueInput>
    disconnect?: Enumerable<injuryWhereUniqueInput>
    delete?: Enumerable<injuryWhereUniqueInput>
    connect?: Enumerable<injuryWhereUniqueInput>
    update?: Enumerable<injuryUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<injuryUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<injuryScalarWhereInput>
  }

  export type foulUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<foulCreateWithoutPlayerInput>, Enumerable<foulUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<foulUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: foulCreateManyPlayerInputEnvelope
    set?: Enumerable<foulWhereUniqueInput>
    disconnect?: Enumerable<foulWhereUniqueInput>
    delete?: Enumerable<foulWhereUniqueInput>
    connect?: Enumerable<foulWhereUniqueInput>
    update?: Enumerable<foulUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<foulUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<foulScalarWhereInput>
  }

  export type cardUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<cardCreateWithoutPlayerInput>, Enumerable<cardUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: cardCreateManyPlayerInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type teamUpdateOneRequiredWithoutPlayerNestedInput = {
    create?: XOR<teamCreateWithoutPlayerInput, teamUncheckedCreateWithoutPlayerInput>
    connectOrCreate?: teamCreateOrConnectWithoutPlayerInput
    upsert?: teamUpsertWithoutPlayerInput
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutPlayerInput, teamUncheckedUpdateWithoutPlayerInput>
  }

  export type switchPlayerUpdateManyWithoutPlayer_outNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_outInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_outInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_outInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutPlayer_outInput>
    createMany?: switchPlayerCreateManyPlayer_outInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutPlayer_outInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutPlayer_outInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type switchPlayerUpdateManyWithoutPlayer_inNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_inInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_inInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_inInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutPlayer_inInput>
    createMany?: switchPlayerCreateManyPlayer_inInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutPlayer_inInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutPlayer_inInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type goalUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<goalCreateWithoutPlayerInput>, Enumerable<goalUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<goalUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: goalCreateManyPlayerInputEnvelope
    set?: Enumerable<goalWhereUniqueInput>
    disconnect?: Enumerable<goalWhereUniqueInput>
    delete?: Enumerable<goalWhereUniqueInput>
    connect?: Enumerable<goalWhereUniqueInput>
    update?: Enumerable<goalUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<goalUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<goalScalarWhereInput>
  }

  export type injuryUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<injuryCreateWithoutPlayerInput>, Enumerable<injuryUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<injuryUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: injuryCreateManyPlayerInputEnvelope
    set?: Enumerable<injuryWhereUniqueInput>
    disconnect?: Enumerable<injuryWhereUniqueInput>
    delete?: Enumerable<injuryWhereUniqueInput>
    connect?: Enumerable<injuryWhereUniqueInput>
    update?: Enumerable<injuryUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<injuryUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<injuryScalarWhereInput>
  }

  export type foulUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<foulCreateWithoutPlayerInput>, Enumerable<foulUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<foulUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: foulCreateManyPlayerInputEnvelope
    set?: Enumerable<foulWhereUniqueInput>
    disconnect?: Enumerable<foulWhereUniqueInput>
    delete?: Enumerable<foulWhereUniqueInput>
    connect?: Enumerable<foulWhereUniqueInput>
    update?: Enumerable<foulUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<foulUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<foulScalarWhereInput>
  }

  export type cardUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<Enumerable<cardCreateWithoutPlayerInput>, Enumerable<cardUncheckedCreateWithoutPlayerInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutPlayerInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutPlayerInput>
    createMany?: cardCreateManyPlayerInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutPlayerInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutPlayerInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_outInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_outInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_outInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutPlayer_outInput>
    createMany?: switchPlayerCreateManyPlayer_outInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutPlayer_outInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutPlayer_outInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutPlayer_inInput>, Enumerable<switchPlayerUncheckedCreateWithoutPlayer_inInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutPlayer_inInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutPlayer_inInput>
    createMany?: switchPlayerCreateManyPlayer_inInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutPlayer_inInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutPlayer_inInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type matchCreateNestedManyWithoutHome_teamInput = {
    create?: XOR<Enumerable<matchCreateWithoutHome_teamInput>, Enumerable<matchUncheckedCreateWithoutHome_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutHome_teamInput>
    createMany?: matchCreateManyHome_teamInputEnvelope
    connect?: Enumerable<matchWhereUniqueInput>
  }

  export type matchCreateNestedManyWithoutAway_teamInput = {
    create?: XOR<Enumerable<matchCreateWithoutAway_teamInput>, Enumerable<matchUncheckedCreateWithoutAway_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutAway_teamInput>
    createMany?: matchCreateManyAway_teamInputEnvelope
    connect?: Enumerable<matchWhereUniqueInput>
  }

  export type playerCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<playerCreateWithoutTeamInput>, Enumerable<playerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<playerCreateOrConnectWithoutTeamInput>
    createMany?: playerCreateManyTeamInputEnvelope
    connect?: Enumerable<playerWhereUniqueInput>
  }

  export type offsetCreateNestedManyWithoutOffset_teamInput = {
    create?: XOR<Enumerable<offsetCreateWithoutOffset_teamInput>, Enumerable<offsetUncheckedCreateWithoutOffset_teamInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutOffset_teamInput>
    createMany?: offsetCreateManyOffset_teamInputEnvelope
    connect?: Enumerable<offsetWhereUniqueInput>
  }

  export type ballPossessionCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutTeamInput>, Enumerable<ballPossessionUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutTeamInput>
    createMany?: ballPossessionCreateManyTeamInputEnvelope
    connect?: Enumerable<ballPossessionWhereUniqueInput>
  }

  export type matchUncheckedCreateNestedManyWithoutHome_teamInput = {
    create?: XOR<Enumerable<matchCreateWithoutHome_teamInput>, Enumerable<matchUncheckedCreateWithoutHome_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutHome_teamInput>
    createMany?: matchCreateManyHome_teamInputEnvelope
    connect?: Enumerable<matchWhereUniqueInput>
  }

  export type matchUncheckedCreateNestedManyWithoutAway_teamInput = {
    create?: XOR<Enumerable<matchCreateWithoutAway_teamInput>, Enumerable<matchUncheckedCreateWithoutAway_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutAway_teamInput>
    createMany?: matchCreateManyAway_teamInputEnvelope
    connect?: Enumerable<matchWhereUniqueInput>
  }

  export type playerUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<playerCreateWithoutTeamInput>, Enumerable<playerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<playerCreateOrConnectWithoutTeamInput>
    createMany?: playerCreateManyTeamInputEnvelope
    connect?: Enumerable<playerWhereUniqueInput>
  }

  export type offsetUncheckedCreateNestedManyWithoutOffset_teamInput = {
    create?: XOR<Enumerable<offsetCreateWithoutOffset_teamInput>, Enumerable<offsetUncheckedCreateWithoutOffset_teamInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutOffset_teamInput>
    createMany?: offsetCreateManyOffset_teamInputEnvelope
    connect?: Enumerable<offsetWhereUniqueInput>
  }

  export type ballPossessionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutTeamInput>, Enumerable<ballPossessionUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutTeamInput>
    createMany?: ballPossessionCreateManyTeamInputEnvelope
    connect?: Enumerable<ballPossessionWhereUniqueInput>
  }

  export type matchUpdateManyWithoutHome_teamNestedInput = {
    create?: XOR<Enumerable<matchCreateWithoutHome_teamInput>, Enumerable<matchUncheckedCreateWithoutHome_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutHome_teamInput>
    upsert?: Enumerable<matchUpsertWithWhereUniqueWithoutHome_teamInput>
    createMany?: matchCreateManyHome_teamInputEnvelope
    set?: Enumerable<matchWhereUniqueInput>
    disconnect?: Enumerable<matchWhereUniqueInput>
    delete?: Enumerable<matchWhereUniqueInput>
    connect?: Enumerable<matchWhereUniqueInput>
    update?: Enumerable<matchUpdateWithWhereUniqueWithoutHome_teamInput>
    updateMany?: Enumerable<matchUpdateManyWithWhereWithoutHome_teamInput>
    deleteMany?: Enumerable<matchScalarWhereInput>
  }

  export type matchUpdateManyWithoutAway_teamNestedInput = {
    create?: XOR<Enumerable<matchCreateWithoutAway_teamInput>, Enumerable<matchUncheckedCreateWithoutAway_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutAway_teamInput>
    upsert?: Enumerable<matchUpsertWithWhereUniqueWithoutAway_teamInput>
    createMany?: matchCreateManyAway_teamInputEnvelope
    set?: Enumerable<matchWhereUniqueInput>
    disconnect?: Enumerable<matchWhereUniqueInput>
    delete?: Enumerable<matchWhereUniqueInput>
    connect?: Enumerable<matchWhereUniqueInput>
    update?: Enumerable<matchUpdateWithWhereUniqueWithoutAway_teamInput>
    updateMany?: Enumerable<matchUpdateManyWithWhereWithoutAway_teamInput>
    deleteMany?: Enumerable<matchScalarWhereInput>
  }

  export type playerUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<playerCreateWithoutTeamInput>, Enumerable<playerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<playerCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<playerUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: playerCreateManyTeamInputEnvelope
    set?: Enumerable<playerWhereUniqueInput>
    disconnect?: Enumerable<playerWhereUniqueInput>
    delete?: Enumerable<playerWhereUniqueInput>
    connect?: Enumerable<playerWhereUniqueInput>
    update?: Enumerable<playerUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<playerUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<playerScalarWhereInput>
  }

  export type offsetUpdateManyWithoutOffset_teamNestedInput = {
    create?: XOR<Enumerable<offsetCreateWithoutOffset_teamInput>, Enumerable<offsetUncheckedCreateWithoutOffset_teamInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutOffset_teamInput>
    upsert?: Enumerable<offsetUpsertWithWhereUniqueWithoutOffset_teamInput>
    createMany?: offsetCreateManyOffset_teamInputEnvelope
    set?: Enumerable<offsetWhereUniqueInput>
    disconnect?: Enumerable<offsetWhereUniqueInput>
    delete?: Enumerable<offsetWhereUniqueInput>
    connect?: Enumerable<offsetWhereUniqueInput>
    update?: Enumerable<offsetUpdateWithWhereUniqueWithoutOffset_teamInput>
    updateMany?: Enumerable<offsetUpdateManyWithWhereWithoutOffset_teamInput>
    deleteMany?: Enumerable<offsetScalarWhereInput>
  }

  export type ballPossessionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutTeamInput>, Enumerable<ballPossessionUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<ballPossessionUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: ballPossessionCreateManyTeamInputEnvelope
    set?: Enumerable<ballPossessionWhereUniqueInput>
    disconnect?: Enumerable<ballPossessionWhereUniqueInput>
    delete?: Enumerable<ballPossessionWhereUniqueInput>
    connect?: Enumerable<ballPossessionWhereUniqueInput>
    update?: Enumerable<ballPossessionUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<ballPossessionUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<ballPossessionScalarWhereInput>
  }

  export type matchUncheckedUpdateManyWithoutHome_teamNestedInput = {
    create?: XOR<Enumerable<matchCreateWithoutHome_teamInput>, Enumerable<matchUncheckedCreateWithoutHome_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutHome_teamInput>
    upsert?: Enumerable<matchUpsertWithWhereUniqueWithoutHome_teamInput>
    createMany?: matchCreateManyHome_teamInputEnvelope
    set?: Enumerable<matchWhereUniqueInput>
    disconnect?: Enumerable<matchWhereUniqueInput>
    delete?: Enumerable<matchWhereUniqueInput>
    connect?: Enumerable<matchWhereUniqueInput>
    update?: Enumerable<matchUpdateWithWhereUniqueWithoutHome_teamInput>
    updateMany?: Enumerable<matchUpdateManyWithWhereWithoutHome_teamInput>
    deleteMany?: Enumerable<matchScalarWhereInput>
  }

  export type matchUncheckedUpdateManyWithoutAway_teamNestedInput = {
    create?: XOR<Enumerable<matchCreateWithoutAway_teamInput>, Enumerable<matchUncheckedCreateWithoutAway_teamInput>>
    connectOrCreate?: Enumerable<matchCreateOrConnectWithoutAway_teamInput>
    upsert?: Enumerable<matchUpsertWithWhereUniqueWithoutAway_teamInput>
    createMany?: matchCreateManyAway_teamInputEnvelope
    set?: Enumerable<matchWhereUniqueInput>
    disconnect?: Enumerable<matchWhereUniqueInput>
    delete?: Enumerable<matchWhereUniqueInput>
    connect?: Enumerable<matchWhereUniqueInput>
    update?: Enumerable<matchUpdateWithWhereUniqueWithoutAway_teamInput>
    updateMany?: Enumerable<matchUpdateManyWithWhereWithoutAway_teamInput>
    deleteMany?: Enumerable<matchScalarWhereInput>
  }

  export type playerUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<playerCreateWithoutTeamInput>, Enumerable<playerUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<playerCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<playerUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: playerCreateManyTeamInputEnvelope
    set?: Enumerable<playerWhereUniqueInput>
    disconnect?: Enumerable<playerWhereUniqueInput>
    delete?: Enumerable<playerWhereUniqueInput>
    connect?: Enumerable<playerWhereUniqueInput>
    update?: Enumerable<playerUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<playerUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<playerScalarWhereInput>
  }

  export type offsetUncheckedUpdateManyWithoutOffset_teamNestedInput = {
    create?: XOR<Enumerable<offsetCreateWithoutOffset_teamInput>, Enumerable<offsetUncheckedCreateWithoutOffset_teamInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutOffset_teamInput>
    upsert?: Enumerable<offsetUpsertWithWhereUniqueWithoutOffset_teamInput>
    createMany?: offsetCreateManyOffset_teamInputEnvelope
    set?: Enumerable<offsetWhereUniqueInput>
    disconnect?: Enumerable<offsetWhereUniqueInput>
    delete?: Enumerable<offsetWhereUniqueInput>
    connect?: Enumerable<offsetWhereUniqueInput>
    update?: Enumerable<offsetUpdateWithWhereUniqueWithoutOffset_teamInput>
    updateMany?: Enumerable<offsetUpdateManyWithWhereWithoutOffset_teamInput>
    deleteMany?: Enumerable<offsetScalarWhereInput>
  }

  export type ballPossessionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutTeamInput>, Enumerable<ballPossessionUncheckedCreateWithoutTeamInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutTeamInput>
    upsert?: Enumerable<ballPossessionUpsertWithWhereUniqueWithoutTeamInput>
    createMany?: ballPossessionCreateManyTeamInputEnvelope
    set?: Enumerable<ballPossessionWhereUniqueInput>
    disconnect?: Enumerable<ballPossessionWhereUniqueInput>
    delete?: Enumerable<ballPossessionWhereUniqueInput>
    connect?: Enumerable<ballPossessionWhereUniqueInput>
    update?: Enumerable<ballPossessionUpdateWithWhereUniqueWithoutTeamInput>
    updateMany?: Enumerable<ballPossessionUpdateManyWithWhereWithoutTeamInput>
    deleteMany?: Enumerable<ballPossessionScalarWhereInput>
  }

  export type teamCreateNestedOneWithoutMatch1Input = {
    create?: XOR<teamCreateWithoutMatch1Input, teamUncheckedCreateWithoutMatch1Input>
    connectOrCreate?: teamCreateOrConnectWithoutMatch1Input
    connect?: teamWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutMatch2Input = {
    create?: XOR<teamCreateWithoutMatch2Input, teamUncheckedCreateWithoutMatch2Input>
    connectOrCreate?: teamCreateOrConnectWithoutMatch2Input
    connect?: teamWhereUniqueInput
  }

  export type offsetCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<offsetCreateWithoutMatchInput>, Enumerable<offsetUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutMatchInput>
    createMany?: offsetCreateManyMatchInputEnvelope
    connect?: Enumerable<offsetWhereUniqueInput>
  }

  export type goalCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<goalCreateWithoutMatchInput>, Enumerable<goalUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutMatchInput>
    createMany?: goalCreateManyMatchInputEnvelope
    connect?: Enumerable<goalWhereUniqueInput>
  }

  export type foulCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<foulCreateWithoutMatchInput>, Enumerable<foulUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutMatchInput>
    createMany?: foulCreateManyMatchInputEnvelope
    connect?: Enumerable<foulWhereUniqueInput>
  }

  export type injuryCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<injuryCreateWithoutMatchInput>, Enumerable<injuryUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutMatchInput>
    createMany?: injuryCreateManyMatchInputEnvelope
    connect?: Enumerable<injuryWhereUniqueInput>
  }

  export type ballPossessionCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutMatchInput>, Enumerable<ballPossessionUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutMatchInput>
    createMany?: ballPossessionCreateManyMatchInputEnvelope
    connect?: Enumerable<ballPossessionWhereUniqueInput>
  }

  export type cardCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<cardCreateWithoutMatchInput>, Enumerable<cardUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutMatchInput>
    createMany?: cardCreateManyMatchInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type switchPlayerCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutMatchInput>, Enumerable<switchPlayerUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutMatchInput>
    createMany?: switchPlayerCreateManyMatchInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type offsetUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<offsetCreateWithoutMatchInput>, Enumerable<offsetUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutMatchInput>
    createMany?: offsetCreateManyMatchInputEnvelope
    connect?: Enumerable<offsetWhereUniqueInput>
  }

  export type goalUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<goalCreateWithoutMatchInput>, Enumerable<goalUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutMatchInput>
    createMany?: goalCreateManyMatchInputEnvelope
    connect?: Enumerable<goalWhereUniqueInput>
  }

  export type foulUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<foulCreateWithoutMatchInput>, Enumerable<foulUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutMatchInput>
    createMany?: foulCreateManyMatchInputEnvelope
    connect?: Enumerable<foulWhereUniqueInput>
  }

  export type injuryUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<injuryCreateWithoutMatchInput>, Enumerable<injuryUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutMatchInput>
    createMany?: injuryCreateManyMatchInputEnvelope
    connect?: Enumerable<injuryWhereUniqueInput>
  }

  export type ballPossessionUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutMatchInput>, Enumerable<ballPossessionUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutMatchInput>
    createMany?: ballPossessionCreateManyMatchInputEnvelope
    connect?: Enumerable<ballPossessionWhereUniqueInput>
  }

  export type cardUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<cardCreateWithoutMatchInput>, Enumerable<cardUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutMatchInput>
    createMany?: cardCreateManyMatchInputEnvelope
    connect?: Enumerable<cardWhereUniqueInput>
  }

  export type switchPlayerUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutMatchInput>, Enumerable<switchPlayerUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutMatchInput>
    createMany?: switchPlayerCreateManyMatchInputEnvelope
    connect?: Enumerable<switchPlayerWhereUniqueInput>
  }

  export type teamUpdateOneRequiredWithoutMatch1NestedInput = {
    create?: XOR<teamCreateWithoutMatch1Input, teamUncheckedCreateWithoutMatch1Input>
    connectOrCreate?: teamCreateOrConnectWithoutMatch1Input
    upsert?: teamUpsertWithoutMatch1Input
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutMatch1Input, teamUncheckedUpdateWithoutMatch1Input>
  }

  export type teamUpdateOneRequiredWithoutMatch2NestedInput = {
    create?: XOR<teamCreateWithoutMatch2Input, teamUncheckedCreateWithoutMatch2Input>
    connectOrCreate?: teamCreateOrConnectWithoutMatch2Input
    upsert?: teamUpsertWithoutMatch2Input
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutMatch2Input, teamUncheckedUpdateWithoutMatch2Input>
  }

  export type offsetUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<offsetCreateWithoutMatchInput>, Enumerable<offsetUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<offsetUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: offsetCreateManyMatchInputEnvelope
    set?: Enumerable<offsetWhereUniqueInput>
    disconnect?: Enumerable<offsetWhereUniqueInput>
    delete?: Enumerable<offsetWhereUniqueInput>
    connect?: Enumerable<offsetWhereUniqueInput>
    update?: Enumerable<offsetUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<offsetUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<offsetScalarWhereInput>
  }

  export type goalUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<goalCreateWithoutMatchInput>, Enumerable<goalUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<goalUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: goalCreateManyMatchInputEnvelope
    set?: Enumerable<goalWhereUniqueInput>
    disconnect?: Enumerable<goalWhereUniqueInput>
    delete?: Enumerable<goalWhereUniqueInput>
    connect?: Enumerable<goalWhereUniqueInput>
    update?: Enumerable<goalUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<goalUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<goalScalarWhereInput>
  }

  export type foulUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<foulCreateWithoutMatchInput>, Enumerable<foulUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<foulUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: foulCreateManyMatchInputEnvelope
    set?: Enumerable<foulWhereUniqueInput>
    disconnect?: Enumerable<foulWhereUniqueInput>
    delete?: Enumerable<foulWhereUniqueInput>
    connect?: Enumerable<foulWhereUniqueInput>
    update?: Enumerable<foulUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<foulUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<foulScalarWhereInput>
  }

  export type injuryUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<injuryCreateWithoutMatchInput>, Enumerable<injuryUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<injuryUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: injuryCreateManyMatchInputEnvelope
    set?: Enumerable<injuryWhereUniqueInput>
    disconnect?: Enumerable<injuryWhereUniqueInput>
    delete?: Enumerable<injuryWhereUniqueInput>
    connect?: Enumerable<injuryWhereUniqueInput>
    update?: Enumerable<injuryUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<injuryUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<injuryScalarWhereInput>
  }

  export type ballPossessionUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutMatchInput>, Enumerable<ballPossessionUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<ballPossessionUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: ballPossessionCreateManyMatchInputEnvelope
    set?: Enumerable<ballPossessionWhereUniqueInput>
    disconnect?: Enumerable<ballPossessionWhereUniqueInput>
    delete?: Enumerable<ballPossessionWhereUniqueInput>
    connect?: Enumerable<ballPossessionWhereUniqueInput>
    update?: Enumerable<ballPossessionUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<ballPossessionUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<ballPossessionScalarWhereInput>
  }

  export type cardUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<cardCreateWithoutMatchInput>, Enumerable<cardUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: cardCreateManyMatchInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type switchPlayerUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutMatchInput>, Enumerable<switchPlayerUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: switchPlayerCreateManyMatchInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type offsetUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<offsetCreateWithoutMatchInput>, Enumerable<offsetUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<offsetCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<offsetUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: offsetCreateManyMatchInputEnvelope
    set?: Enumerable<offsetWhereUniqueInput>
    disconnect?: Enumerable<offsetWhereUniqueInput>
    delete?: Enumerable<offsetWhereUniqueInput>
    connect?: Enumerable<offsetWhereUniqueInput>
    update?: Enumerable<offsetUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<offsetUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<offsetScalarWhereInput>
  }

  export type goalUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<goalCreateWithoutMatchInput>, Enumerable<goalUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<goalCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<goalUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: goalCreateManyMatchInputEnvelope
    set?: Enumerable<goalWhereUniqueInput>
    disconnect?: Enumerable<goalWhereUniqueInput>
    delete?: Enumerable<goalWhereUniqueInput>
    connect?: Enumerable<goalWhereUniqueInput>
    update?: Enumerable<goalUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<goalUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<goalScalarWhereInput>
  }

  export type foulUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<foulCreateWithoutMatchInput>, Enumerable<foulUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<foulCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<foulUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: foulCreateManyMatchInputEnvelope
    set?: Enumerable<foulWhereUniqueInput>
    disconnect?: Enumerable<foulWhereUniqueInput>
    delete?: Enumerable<foulWhereUniqueInput>
    connect?: Enumerable<foulWhereUniqueInput>
    update?: Enumerable<foulUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<foulUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<foulScalarWhereInput>
  }

  export type injuryUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<injuryCreateWithoutMatchInput>, Enumerable<injuryUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<injuryCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<injuryUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: injuryCreateManyMatchInputEnvelope
    set?: Enumerable<injuryWhereUniqueInput>
    disconnect?: Enumerable<injuryWhereUniqueInput>
    delete?: Enumerable<injuryWhereUniqueInput>
    connect?: Enumerable<injuryWhereUniqueInput>
    update?: Enumerable<injuryUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<injuryUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<injuryScalarWhereInput>
  }

  export type ballPossessionUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<ballPossessionCreateWithoutMatchInput>, Enumerable<ballPossessionUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<ballPossessionCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<ballPossessionUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: ballPossessionCreateManyMatchInputEnvelope
    set?: Enumerable<ballPossessionWhereUniqueInput>
    disconnect?: Enumerable<ballPossessionWhereUniqueInput>
    delete?: Enumerable<ballPossessionWhereUniqueInput>
    connect?: Enumerable<ballPossessionWhereUniqueInput>
    update?: Enumerable<ballPossessionUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<ballPossessionUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<ballPossessionScalarWhereInput>
  }

  export type cardUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<cardCreateWithoutMatchInput>, Enumerable<cardUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<cardCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<cardUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: cardCreateManyMatchInputEnvelope
    set?: Enumerable<cardWhereUniqueInput>
    disconnect?: Enumerable<cardWhereUniqueInput>
    delete?: Enumerable<cardWhereUniqueInput>
    connect?: Enumerable<cardWhereUniqueInput>
    update?: Enumerable<cardUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<cardUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<cardScalarWhereInput>
  }

  export type switchPlayerUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<Enumerable<switchPlayerCreateWithoutMatchInput>, Enumerable<switchPlayerUncheckedCreateWithoutMatchInput>>
    connectOrCreate?: Enumerable<switchPlayerCreateOrConnectWithoutMatchInput>
    upsert?: Enumerable<switchPlayerUpsertWithWhereUniqueWithoutMatchInput>
    createMany?: switchPlayerCreateManyMatchInputEnvelope
    set?: Enumerable<switchPlayerWhereUniqueInput>
    disconnect?: Enumerable<switchPlayerWhereUniqueInput>
    delete?: Enumerable<switchPlayerWhereUniqueInput>
    connect?: Enumerable<switchPlayerWhereUniqueInput>
    update?: Enumerable<switchPlayerUpdateWithWhereUniqueWithoutMatchInput>
    updateMany?: Enumerable<switchPlayerUpdateManyWithWhereWithoutMatchInput>
    deleteMany?: Enumerable<switchPlayerScalarWhereInput>
  }

  export type matchCreateNestedOneWithoutOffsetInput = {
    create?: XOR<matchCreateWithoutOffsetInput, matchUncheckedCreateWithoutOffsetInput>
    connectOrCreate?: matchCreateOrConnectWithoutOffsetInput
    connect?: matchWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutOffsetInput = {
    create?: XOR<teamCreateWithoutOffsetInput, teamUncheckedCreateWithoutOffsetInput>
    connectOrCreate?: teamCreateOrConnectWithoutOffsetInput
    connect?: teamWhereUniqueInput
  }

  export type matchUpdateOneRequiredWithoutOffsetNestedInput = {
    create?: XOR<matchCreateWithoutOffsetInput, matchUncheckedCreateWithoutOffsetInput>
    connectOrCreate?: matchCreateOrConnectWithoutOffsetInput
    upsert?: matchUpsertWithoutOffsetInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutOffsetInput, matchUncheckedUpdateWithoutOffsetInput>
  }

  export type teamUpdateOneRequiredWithoutOffsetNestedInput = {
    create?: XOR<teamCreateWithoutOffsetInput, teamUncheckedCreateWithoutOffsetInput>
    connectOrCreate?: teamCreateOrConnectWithoutOffsetInput
    upsert?: teamUpsertWithoutOffsetInput
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutOffsetInput, teamUncheckedUpdateWithoutOffsetInput>
  }

  export type playerCreateNestedOneWithoutGoalsInput = {
    create?: XOR<playerCreateWithoutGoalsInput, playerUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: playerCreateOrConnectWithoutGoalsInput
    connect?: playerWhereUniqueInput
  }

  export type matchCreateNestedOneWithoutGoalInput = {
    create?: XOR<matchCreateWithoutGoalInput, matchUncheckedCreateWithoutGoalInput>
    connectOrCreate?: matchCreateOrConnectWithoutGoalInput
    connect?: matchWhereUniqueInput
  }

  export type playerUpdateOneRequiredWithoutGoalsNestedInput = {
    create?: XOR<playerCreateWithoutGoalsInput, playerUncheckedCreateWithoutGoalsInput>
    connectOrCreate?: playerCreateOrConnectWithoutGoalsInput
    upsert?: playerUpsertWithoutGoalsInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutGoalsInput, playerUncheckedUpdateWithoutGoalsInput>
  }

  export type matchUpdateOneRequiredWithoutGoalNestedInput = {
    create?: XOR<matchCreateWithoutGoalInput, matchUncheckedCreateWithoutGoalInput>
    connectOrCreate?: matchCreateOrConnectWithoutGoalInput
    upsert?: matchUpsertWithoutGoalInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutGoalInput, matchUncheckedUpdateWithoutGoalInput>
  }

  export type playerCreateNestedOneWithoutFoulsInput = {
    create?: XOR<playerCreateWithoutFoulsInput, playerUncheckedCreateWithoutFoulsInput>
    connectOrCreate?: playerCreateOrConnectWithoutFoulsInput
    connect?: playerWhereUniqueInput
  }

  export type matchCreateNestedOneWithoutFoulInput = {
    create?: XOR<matchCreateWithoutFoulInput, matchUncheckedCreateWithoutFoulInput>
    connectOrCreate?: matchCreateOrConnectWithoutFoulInput
    connect?: matchWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type playerUpdateOneRequiredWithoutFoulsNestedInput = {
    create?: XOR<playerCreateWithoutFoulsInput, playerUncheckedCreateWithoutFoulsInput>
    connectOrCreate?: playerCreateOrConnectWithoutFoulsInput
    upsert?: playerUpsertWithoutFoulsInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutFoulsInput, playerUncheckedUpdateWithoutFoulsInput>
  }

  export type matchUpdateOneRequiredWithoutFoulNestedInput = {
    create?: XOR<matchCreateWithoutFoulInput, matchUncheckedCreateWithoutFoulInput>
    connectOrCreate?: matchCreateOrConnectWithoutFoulInput
    upsert?: matchUpsertWithoutFoulInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutFoulInput, matchUncheckedUpdateWithoutFoulInput>
  }

  export type playerCreateNestedOneWithoutInjurysInput = {
    create?: XOR<playerCreateWithoutInjurysInput, playerUncheckedCreateWithoutInjurysInput>
    connectOrCreate?: playerCreateOrConnectWithoutInjurysInput
    connect?: playerWhereUniqueInput
  }

  export type matchCreateNestedOneWithoutInjuryInput = {
    create?: XOR<matchCreateWithoutInjuryInput, matchUncheckedCreateWithoutInjuryInput>
    connectOrCreate?: matchCreateOrConnectWithoutInjuryInput
    connect?: matchWhereUniqueInput
  }

  export type playerUpdateOneRequiredWithoutInjurysNestedInput = {
    create?: XOR<playerCreateWithoutInjurysInput, playerUncheckedCreateWithoutInjurysInput>
    connectOrCreate?: playerCreateOrConnectWithoutInjurysInput
    upsert?: playerUpsertWithoutInjurysInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutInjurysInput, playerUncheckedUpdateWithoutInjurysInput>
  }

  export type matchUpdateOneRequiredWithoutInjuryNestedInput = {
    create?: XOR<matchCreateWithoutInjuryInput, matchUncheckedCreateWithoutInjuryInput>
    connectOrCreate?: matchCreateOrConnectWithoutInjuryInput
    upsert?: matchUpsertWithoutInjuryInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutInjuryInput, matchUncheckedUpdateWithoutInjuryInput>
  }

  export type matchCreateNestedOneWithoutBallPossessionInput = {
    create?: XOR<matchCreateWithoutBallPossessionInput, matchUncheckedCreateWithoutBallPossessionInput>
    connectOrCreate?: matchCreateOrConnectWithoutBallPossessionInput
    connect?: matchWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutBallPossessionInput = {
    create?: XOR<teamCreateWithoutBallPossessionInput, teamUncheckedCreateWithoutBallPossessionInput>
    connectOrCreate?: teamCreateOrConnectWithoutBallPossessionInput
    connect?: teamWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type matchUpdateOneRequiredWithoutBallPossessionNestedInput = {
    create?: XOR<matchCreateWithoutBallPossessionInput, matchUncheckedCreateWithoutBallPossessionInput>
    connectOrCreate?: matchCreateOrConnectWithoutBallPossessionInput
    upsert?: matchUpsertWithoutBallPossessionInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutBallPossessionInput, matchUncheckedUpdateWithoutBallPossessionInput>
  }

  export type teamUpdateOneRequiredWithoutBallPossessionNestedInput = {
    create?: XOR<teamCreateWithoutBallPossessionInput, teamUncheckedCreateWithoutBallPossessionInput>
    connectOrCreate?: teamCreateOrConnectWithoutBallPossessionInput
    upsert?: teamUpsertWithoutBallPossessionInput
    connect?: teamWhereUniqueInput
    update?: XOR<teamUpdateWithoutBallPossessionInput, teamUncheckedUpdateWithoutBallPossessionInput>
  }

  export type matchCreateNestedOneWithoutCardInput = {
    create?: XOR<matchCreateWithoutCardInput, matchUncheckedCreateWithoutCardInput>
    connectOrCreate?: matchCreateOrConnectWithoutCardInput
    connect?: matchWhereUniqueInput
  }

  export type playerCreateNestedOneWithoutCardsInput = {
    create?: XOR<playerCreateWithoutCardsInput, playerUncheckedCreateWithoutCardsInput>
    connectOrCreate?: playerCreateOrConnectWithoutCardsInput
    connect?: playerWhereUniqueInput
  }

  export type matchUpdateOneRequiredWithoutCardNestedInput = {
    create?: XOR<matchCreateWithoutCardInput, matchUncheckedCreateWithoutCardInput>
    connectOrCreate?: matchCreateOrConnectWithoutCardInput
    upsert?: matchUpsertWithoutCardInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutCardInput, matchUncheckedUpdateWithoutCardInput>
  }

  export type playerUpdateOneRequiredWithoutCardsNestedInput = {
    create?: XOR<playerCreateWithoutCardsInput, playerUncheckedCreateWithoutCardsInput>
    connectOrCreate?: playerCreateOrConnectWithoutCardsInput
    upsert?: playerUpsertWithoutCardsInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutCardsInput, playerUncheckedUpdateWithoutCardsInput>
  }

  export type matchCreateNestedOneWithoutSwitchPlayerInput = {
    create?: XOR<matchCreateWithoutSwitchPlayerInput, matchUncheckedCreateWithoutSwitchPlayerInput>
    connectOrCreate?: matchCreateOrConnectWithoutSwitchPlayerInput
    connect?: matchWhereUniqueInput
  }

  export type playerCreateNestedOneWithoutSwitchPlayerOutInput = {
    create?: XOR<playerCreateWithoutSwitchPlayerOutInput, playerUncheckedCreateWithoutSwitchPlayerOutInput>
    connectOrCreate?: playerCreateOrConnectWithoutSwitchPlayerOutInput
    connect?: playerWhereUniqueInput
  }

  export type playerCreateNestedOneWithoutSwitchPlayerInInput = {
    create?: XOR<playerCreateWithoutSwitchPlayerInInput, playerUncheckedCreateWithoutSwitchPlayerInInput>
    connectOrCreate?: playerCreateOrConnectWithoutSwitchPlayerInInput
    connect?: playerWhereUniqueInput
  }

  export type matchUpdateOneRequiredWithoutSwitchPlayerNestedInput = {
    create?: XOR<matchCreateWithoutSwitchPlayerInput, matchUncheckedCreateWithoutSwitchPlayerInput>
    connectOrCreate?: matchCreateOrConnectWithoutSwitchPlayerInput
    upsert?: matchUpsertWithoutSwitchPlayerInput
    connect?: matchWhereUniqueInput
    update?: XOR<matchUpdateWithoutSwitchPlayerInput, matchUncheckedUpdateWithoutSwitchPlayerInput>
  }

  export type playerUpdateOneRequiredWithoutSwitchPlayerOutNestedInput = {
    create?: XOR<playerCreateWithoutSwitchPlayerOutInput, playerUncheckedCreateWithoutSwitchPlayerOutInput>
    connectOrCreate?: playerCreateOrConnectWithoutSwitchPlayerOutInput
    upsert?: playerUpsertWithoutSwitchPlayerOutInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutSwitchPlayerOutInput, playerUncheckedUpdateWithoutSwitchPlayerOutInput>
  }

  export type playerUpdateOneRequiredWithoutSwitchPlayerInNestedInput = {
    create?: XOR<playerCreateWithoutSwitchPlayerInInput, playerUncheckedCreateWithoutSwitchPlayerInInput>
    connectOrCreate?: playerCreateOrConnectWithoutSwitchPlayerInInput
    upsert?: playerUpsertWithoutSwitchPlayerInInput
    connect?: playerWhereUniqueInput
    update?: XOR<playerUpdateWithoutSwitchPlayerInInput, playerUncheckedUpdateWithoutSwitchPlayerInInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumStatusFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusFilter | Status
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumStatusWithAggregatesFilter = {
    equals?: Status
    in?: Enumerable<Status>
    notIn?: Enumerable<Status>
    not?: NestedEnumStatusWithAggregatesFilter | Status
    _count?: NestedIntFilter
    _min?: NestedEnumStatusFilter
    _max?: NestedEnumStatusFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type goalCreateWithoutPlayerInput = {
    goal_time: number
    match: matchCreateNestedOneWithoutGoalInput
  }

  export type goalUncheckedCreateWithoutPlayerInput = {
    id?: number
    match_id: number
    goal_time: number
  }

  export type goalCreateOrConnectWithoutPlayerInput = {
    where: goalWhereUniqueInput
    create: XOR<goalCreateWithoutPlayerInput, goalUncheckedCreateWithoutPlayerInput>
  }

  export type goalCreateManyPlayerInputEnvelope = {
    data: Enumerable<goalCreateManyPlayerInput>
    skipDuplicates?: boolean
  }

  export type injuryCreateWithoutPlayerInput = {
    injury_type: string
    match: matchCreateNestedOneWithoutInjuryInput
  }

  export type injuryUncheckedCreateWithoutPlayerInput = {
    id?: number
    match_id: number
    injury_type: string
  }

  export type injuryCreateOrConnectWithoutPlayerInput = {
    where: injuryWhereUniqueInput
    create: XOR<injuryCreateWithoutPlayerInput, injuryUncheckedCreateWithoutPlayerInput>
  }

  export type injuryCreateManyPlayerInputEnvelope = {
    data: Enumerable<injuryCreateManyPlayerInput>
    skipDuplicates?: boolean
  }

  export type foulCreateWithoutPlayerInput = {
    team_id: number
    type?: string | null
    match: matchCreateNestedOneWithoutFoulInput
  }

  export type foulUncheckedCreateWithoutPlayerInput = {
    id?: number
    match_id: number
    team_id: number
    type?: string | null
  }

  export type foulCreateOrConnectWithoutPlayerInput = {
    where: foulWhereUniqueInput
    create: XOR<foulCreateWithoutPlayerInput, foulUncheckedCreateWithoutPlayerInput>
  }

  export type foulCreateManyPlayerInputEnvelope = {
    data: Enumerable<foulCreateManyPlayerInput>
    skipDuplicates?: boolean
  }

  export type cardCreateWithoutPlayerInput = {
    card_type: string
    card_time: number
    match: matchCreateNestedOneWithoutCardInput
  }

  export type cardUncheckedCreateWithoutPlayerInput = {
    id?: number
    match_id: number
    card_type: string
    card_time: number
  }

  export type cardCreateOrConnectWithoutPlayerInput = {
    where: cardWhereUniqueInput
    create: XOR<cardCreateWithoutPlayerInput, cardUncheckedCreateWithoutPlayerInput>
  }

  export type cardCreateManyPlayerInputEnvelope = {
    data: Enumerable<cardCreateManyPlayerInput>
    skipDuplicates?: boolean
  }

  export type teamCreateWithoutPlayerInput = {
    name: string
    logo: string
    match1?: matchCreateNestedManyWithoutHome_teamInput
    match2?: matchCreateNestedManyWithoutAway_teamInput
    offset?: offsetCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutPlayerInput = {
    id?: number
    name: string
    logo: string
    match1?: matchUncheckedCreateNestedManyWithoutHome_teamInput
    match2?: matchUncheckedCreateNestedManyWithoutAway_teamInput
    offset?: offsetUncheckedCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutPlayerInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutPlayerInput, teamUncheckedCreateWithoutPlayerInput>
  }

  export type switchPlayerCreateWithoutPlayer_outInput = {
    switch_time: number
    match: matchCreateNestedOneWithoutSwitchPlayerInput
    player_in: playerCreateNestedOneWithoutSwitchPlayerInInput
  }

  export type switchPlayerUncheckedCreateWithoutPlayer_outInput = {
    id?: number
    match_id: number
    player_in_id: number
    switch_time: number
  }

  export type switchPlayerCreateOrConnectWithoutPlayer_outInput = {
    where: switchPlayerWhereUniqueInput
    create: XOR<switchPlayerCreateWithoutPlayer_outInput, switchPlayerUncheckedCreateWithoutPlayer_outInput>
  }

  export type switchPlayerCreateManyPlayer_outInputEnvelope = {
    data: Enumerable<switchPlayerCreateManyPlayer_outInput>
    skipDuplicates?: boolean
  }

  export type switchPlayerCreateWithoutPlayer_inInput = {
    switch_time: number
    match: matchCreateNestedOneWithoutSwitchPlayerInput
    player_out: playerCreateNestedOneWithoutSwitchPlayerOutInput
  }

  export type switchPlayerUncheckedCreateWithoutPlayer_inInput = {
    id?: number
    match_id: number
    player_out_id: number
    switch_time: number
  }

  export type switchPlayerCreateOrConnectWithoutPlayer_inInput = {
    where: switchPlayerWhereUniqueInput
    create: XOR<switchPlayerCreateWithoutPlayer_inInput, switchPlayerUncheckedCreateWithoutPlayer_inInput>
  }

  export type switchPlayerCreateManyPlayer_inInputEnvelope = {
    data: Enumerable<switchPlayerCreateManyPlayer_inInput>
    skipDuplicates?: boolean
  }

  export type goalUpsertWithWhereUniqueWithoutPlayerInput = {
    where: goalWhereUniqueInput
    update: XOR<goalUpdateWithoutPlayerInput, goalUncheckedUpdateWithoutPlayerInput>
    create: XOR<goalCreateWithoutPlayerInput, goalUncheckedCreateWithoutPlayerInput>
  }

  export type goalUpdateWithWhereUniqueWithoutPlayerInput = {
    where: goalWhereUniqueInput
    data: XOR<goalUpdateWithoutPlayerInput, goalUncheckedUpdateWithoutPlayerInput>
  }

  export type goalUpdateManyWithWhereWithoutPlayerInput = {
    where: goalScalarWhereInput
    data: XOR<goalUpdateManyMutationInput, goalUncheckedUpdateManyWithoutGoalsInput>
  }

  export type goalScalarWhereInput = {
    AND?: Enumerable<goalScalarWhereInput>
    OR?: Enumerable<goalScalarWhereInput>
    NOT?: Enumerable<goalScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    goal_time?: IntFilter | number
  }

  export type injuryUpsertWithWhereUniqueWithoutPlayerInput = {
    where: injuryWhereUniqueInput
    update: XOR<injuryUpdateWithoutPlayerInput, injuryUncheckedUpdateWithoutPlayerInput>
    create: XOR<injuryCreateWithoutPlayerInput, injuryUncheckedCreateWithoutPlayerInput>
  }

  export type injuryUpdateWithWhereUniqueWithoutPlayerInput = {
    where: injuryWhereUniqueInput
    data: XOR<injuryUpdateWithoutPlayerInput, injuryUncheckedUpdateWithoutPlayerInput>
  }

  export type injuryUpdateManyWithWhereWithoutPlayerInput = {
    where: injuryScalarWhereInput
    data: XOR<injuryUpdateManyMutationInput, injuryUncheckedUpdateManyWithoutInjurysInput>
  }

  export type injuryScalarWhereInput = {
    AND?: Enumerable<injuryScalarWhereInput>
    OR?: Enumerable<injuryScalarWhereInput>
    NOT?: Enumerable<injuryScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    injury_type?: StringFilter | string
  }

  export type foulUpsertWithWhereUniqueWithoutPlayerInput = {
    where: foulWhereUniqueInput
    update: XOR<foulUpdateWithoutPlayerInput, foulUncheckedUpdateWithoutPlayerInput>
    create: XOR<foulCreateWithoutPlayerInput, foulUncheckedCreateWithoutPlayerInput>
  }

  export type foulUpdateWithWhereUniqueWithoutPlayerInput = {
    where: foulWhereUniqueInput
    data: XOR<foulUpdateWithoutPlayerInput, foulUncheckedUpdateWithoutPlayerInput>
  }

  export type foulUpdateManyWithWhereWithoutPlayerInput = {
    where: foulScalarWhereInput
    data: XOR<foulUpdateManyMutationInput, foulUncheckedUpdateManyWithoutFoulsInput>
  }

  export type foulScalarWhereInput = {
    AND?: Enumerable<foulScalarWhereInput>
    OR?: Enumerable<foulScalarWhereInput>
    NOT?: Enumerable<foulScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    team_id?: IntFilter | number
    player_id?: IntFilter | number
    type?: StringNullableFilter | string | null
  }

  export type cardUpsertWithWhereUniqueWithoutPlayerInput = {
    where: cardWhereUniqueInput
    update: XOR<cardUpdateWithoutPlayerInput, cardUncheckedUpdateWithoutPlayerInput>
    create: XOR<cardCreateWithoutPlayerInput, cardUncheckedCreateWithoutPlayerInput>
  }

  export type cardUpdateWithWhereUniqueWithoutPlayerInput = {
    where: cardWhereUniqueInput
    data: XOR<cardUpdateWithoutPlayerInput, cardUncheckedUpdateWithoutPlayerInput>
  }

  export type cardUpdateManyWithWhereWithoutPlayerInput = {
    where: cardScalarWhereInput
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyWithoutCardsInput>
  }

  export type cardScalarWhereInput = {
    AND?: Enumerable<cardScalarWhereInput>
    OR?: Enumerable<cardScalarWhereInput>
    NOT?: Enumerable<cardScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_id?: IntFilter | number
    card_type?: StringFilter | string
    card_time?: IntFilter | number
  }

  export type teamUpsertWithoutPlayerInput = {
    update: XOR<teamUpdateWithoutPlayerInput, teamUncheckedUpdateWithoutPlayerInput>
    create: XOR<teamCreateWithoutPlayerInput, teamUncheckedCreateWithoutPlayerInput>
  }

  export type teamUpdateWithoutPlayerInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUpdateManyWithoutHome_teamNestedInput
    match2?: matchUpdateManyWithoutAway_teamNestedInput
    offset?: offsetUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUncheckedUpdateManyWithoutHome_teamNestedInput
    match2?: matchUncheckedUpdateManyWithoutAway_teamNestedInput
    offset?: offsetUncheckedUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type switchPlayerUpsertWithWhereUniqueWithoutPlayer_outInput = {
    where: switchPlayerWhereUniqueInput
    update: XOR<switchPlayerUpdateWithoutPlayer_outInput, switchPlayerUncheckedUpdateWithoutPlayer_outInput>
    create: XOR<switchPlayerCreateWithoutPlayer_outInput, switchPlayerUncheckedCreateWithoutPlayer_outInput>
  }

  export type switchPlayerUpdateWithWhereUniqueWithoutPlayer_outInput = {
    where: switchPlayerWhereUniqueInput
    data: XOR<switchPlayerUpdateWithoutPlayer_outInput, switchPlayerUncheckedUpdateWithoutPlayer_outInput>
  }

  export type switchPlayerUpdateManyWithWhereWithoutPlayer_outInput = {
    where: switchPlayerScalarWhereInput
    data: XOR<switchPlayerUpdateManyMutationInput, switchPlayerUncheckedUpdateManyWithoutSwitchPlayerOutInput>
  }

  export type switchPlayerScalarWhereInput = {
    AND?: Enumerable<switchPlayerScalarWhereInput>
    OR?: Enumerable<switchPlayerScalarWhereInput>
    NOT?: Enumerable<switchPlayerScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    player_out_id?: IntFilter | number
    player_in_id?: IntFilter | number
    switch_time?: IntFilter | number
  }

  export type switchPlayerUpsertWithWhereUniqueWithoutPlayer_inInput = {
    where: switchPlayerWhereUniqueInput
    update: XOR<switchPlayerUpdateWithoutPlayer_inInput, switchPlayerUncheckedUpdateWithoutPlayer_inInput>
    create: XOR<switchPlayerCreateWithoutPlayer_inInput, switchPlayerUncheckedCreateWithoutPlayer_inInput>
  }

  export type switchPlayerUpdateWithWhereUniqueWithoutPlayer_inInput = {
    where: switchPlayerWhereUniqueInput
    data: XOR<switchPlayerUpdateWithoutPlayer_inInput, switchPlayerUncheckedUpdateWithoutPlayer_inInput>
  }

  export type switchPlayerUpdateManyWithWhereWithoutPlayer_inInput = {
    where: switchPlayerScalarWhereInput
    data: XOR<switchPlayerUpdateManyMutationInput, switchPlayerUncheckedUpdateManyWithoutSwitchPlayerInInput>
  }

  export type matchCreateWithoutHome_teamInput = {
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutHome_teamInput = {
    id?: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutHome_teamInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutHome_teamInput, matchUncheckedCreateWithoutHome_teamInput>
  }

  export type matchCreateManyHome_teamInputEnvelope = {
    data: Enumerable<matchCreateManyHome_teamInput>
    skipDuplicates?: boolean
  }

  export type matchCreateWithoutAway_teamInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutAway_teamInput = {
    id?: number
    homeTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutAway_teamInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutAway_teamInput, matchUncheckedCreateWithoutAway_teamInput>
  }

  export type matchCreateManyAway_teamInputEnvelope = {
    data: Enumerable<matchCreateManyAway_teamInput>
    skipDuplicates?: boolean
  }

  export type playerCreateWithoutTeamInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutTeamInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutTeamInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutTeamInput, playerUncheckedCreateWithoutTeamInput>
  }

  export type playerCreateManyTeamInputEnvelope = {
    data: Enumerable<playerCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type offsetCreateWithoutOffset_teamInput = {
    offset_time: number
    match: matchCreateNestedOneWithoutOffsetInput
  }

  export type offsetUncheckedCreateWithoutOffset_teamInput = {
    id?: number
    match_id: number
    offset_time: number
  }

  export type offsetCreateOrConnectWithoutOffset_teamInput = {
    where: offsetWhereUniqueInput
    create: XOR<offsetCreateWithoutOffset_teamInput, offsetUncheckedCreateWithoutOffset_teamInput>
  }

  export type offsetCreateManyOffset_teamInputEnvelope = {
    data: Enumerable<offsetCreateManyOffset_teamInput>
    skipDuplicates?: boolean
  }

  export type ballPossessionCreateWithoutTeamInput = {
    possession_time: number
    match: matchCreateNestedOneWithoutBallPossessionInput
  }

  export type ballPossessionUncheckedCreateWithoutTeamInput = {
    id?: number
    match_id: number
    possession_time: number
  }

  export type ballPossessionCreateOrConnectWithoutTeamInput = {
    where: ballPossessionWhereUniqueInput
    create: XOR<ballPossessionCreateWithoutTeamInput, ballPossessionUncheckedCreateWithoutTeamInput>
  }

  export type ballPossessionCreateManyTeamInputEnvelope = {
    data: Enumerable<ballPossessionCreateManyTeamInput>
    skipDuplicates?: boolean
  }

  export type matchUpsertWithWhereUniqueWithoutHome_teamInput = {
    where: matchWhereUniqueInput
    update: XOR<matchUpdateWithoutHome_teamInput, matchUncheckedUpdateWithoutHome_teamInput>
    create: XOR<matchCreateWithoutHome_teamInput, matchUncheckedCreateWithoutHome_teamInput>
  }

  export type matchUpdateWithWhereUniqueWithoutHome_teamInput = {
    where: matchWhereUniqueInput
    data: XOR<matchUpdateWithoutHome_teamInput, matchUncheckedUpdateWithoutHome_teamInput>
  }

  export type matchUpdateManyWithWhereWithoutHome_teamInput = {
    where: matchScalarWhereInput
    data: XOR<matchUpdateManyMutationInput, matchUncheckedUpdateManyWithoutMatch1Input>
  }

  export type matchScalarWhereInput = {
    AND?: Enumerable<matchScalarWhereInput>
    OR?: Enumerable<matchScalarWhereInput>
    NOT?: Enumerable<matchScalarWhereInput>
    id?: IntFilter | number
    homeTeam?: IntFilter | number
    awayTeam?: IntFilter | number
  }

  export type matchUpsertWithWhereUniqueWithoutAway_teamInput = {
    where: matchWhereUniqueInput
    update: XOR<matchUpdateWithoutAway_teamInput, matchUncheckedUpdateWithoutAway_teamInput>
    create: XOR<matchCreateWithoutAway_teamInput, matchUncheckedCreateWithoutAway_teamInput>
  }

  export type matchUpdateWithWhereUniqueWithoutAway_teamInput = {
    where: matchWhereUniqueInput
    data: XOR<matchUpdateWithoutAway_teamInput, matchUncheckedUpdateWithoutAway_teamInput>
  }

  export type matchUpdateManyWithWhereWithoutAway_teamInput = {
    where: matchScalarWhereInput
    data: XOR<matchUpdateManyMutationInput, matchUncheckedUpdateManyWithoutMatch2Input>
  }

  export type playerUpsertWithWhereUniqueWithoutTeamInput = {
    where: playerWhereUniqueInput
    update: XOR<playerUpdateWithoutTeamInput, playerUncheckedUpdateWithoutTeamInput>
    create: XOR<playerCreateWithoutTeamInput, playerUncheckedCreateWithoutTeamInput>
  }

  export type playerUpdateWithWhereUniqueWithoutTeamInput = {
    where: playerWhereUniqueInput
    data: XOR<playerUpdateWithoutTeamInput, playerUncheckedUpdateWithoutTeamInput>
  }

  export type playerUpdateManyWithWhereWithoutTeamInput = {
    where: playerScalarWhereInput
    data: XOR<playerUpdateManyMutationInput, playerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type playerScalarWhereInput = {
    AND?: Enumerable<playerScalarWhereInput>
    OR?: Enumerable<playerScalarWhereInput>
    NOT?: Enumerable<playerScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    numberJersey?: StringFilter | string
    position?: StringFilter | string
    status?: EnumStatusFilter | Status
    team_id?: IntFilter | number
  }

  export type offsetUpsertWithWhereUniqueWithoutOffset_teamInput = {
    where: offsetWhereUniqueInput
    update: XOR<offsetUpdateWithoutOffset_teamInput, offsetUncheckedUpdateWithoutOffset_teamInput>
    create: XOR<offsetCreateWithoutOffset_teamInput, offsetUncheckedCreateWithoutOffset_teamInput>
  }

  export type offsetUpdateWithWhereUniqueWithoutOffset_teamInput = {
    where: offsetWhereUniqueInput
    data: XOR<offsetUpdateWithoutOffset_teamInput, offsetUncheckedUpdateWithoutOffset_teamInput>
  }

  export type offsetUpdateManyWithWhereWithoutOffset_teamInput = {
    where: offsetScalarWhereInput
    data: XOR<offsetUpdateManyMutationInput, offsetUncheckedUpdateManyWithoutOffsetInput>
  }

  export type offsetScalarWhereInput = {
    AND?: Enumerable<offsetScalarWhereInput>
    OR?: Enumerable<offsetScalarWhereInput>
    NOT?: Enumerable<offsetScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    offset_team_id?: IntFilter | number
    offset_time?: IntFilter | number
  }

  export type ballPossessionUpsertWithWhereUniqueWithoutTeamInput = {
    where: ballPossessionWhereUniqueInput
    update: XOR<ballPossessionUpdateWithoutTeamInput, ballPossessionUncheckedUpdateWithoutTeamInput>
    create: XOR<ballPossessionCreateWithoutTeamInput, ballPossessionUncheckedCreateWithoutTeamInput>
  }

  export type ballPossessionUpdateWithWhereUniqueWithoutTeamInput = {
    where: ballPossessionWhereUniqueInput
    data: XOR<ballPossessionUpdateWithoutTeamInput, ballPossessionUncheckedUpdateWithoutTeamInput>
  }

  export type ballPossessionUpdateManyWithWhereWithoutTeamInput = {
    where: ballPossessionScalarWhereInput
    data: XOR<ballPossessionUpdateManyMutationInput, ballPossessionUncheckedUpdateManyWithoutBallPossessionInput>
  }

  export type ballPossessionScalarWhereInput = {
    AND?: Enumerable<ballPossessionScalarWhereInput>
    OR?: Enumerable<ballPossessionScalarWhereInput>
    NOT?: Enumerable<ballPossessionScalarWhereInput>
    id?: IntFilter | number
    match_id?: IntFilter | number
    team_id?: IntFilter | number
    possession_time?: FloatFilter | number
  }

  export type teamCreateWithoutMatch1Input = {
    name: string
    logo: string
    match2?: matchCreateNestedManyWithoutAway_teamInput
    player?: playerCreateNestedManyWithoutTeamInput
    offset?: offsetCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutMatch1Input = {
    id?: number
    name: string
    logo: string
    match2?: matchUncheckedCreateNestedManyWithoutAway_teamInput
    player?: playerUncheckedCreateNestedManyWithoutTeamInput
    offset?: offsetUncheckedCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutMatch1Input = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutMatch1Input, teamUncheckedCreateWithoutMatch1Input>
  }

  export type teamCreateWithoutMatch2Input = {
    name: string
    logo: string
    match1?: matchCreateNestedManyWithoutHome_teamInput
    player?: playerCreateNestedManyWithoutTeamInput
    offset?: offsetCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutMatch2Input = {
    id?: number
    name: string
    logo: string
    match1?: matchUncheckedCreateNestedManyWithoutHome_teamInput
    player?: playerUncheckedCreateNestedManyWithoutTeamInput
    offset?: offsetUncheckedCreateNestedManyWithoutOffset_teamInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutMatch2Input = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutMatch2Input, teamUncheckedCreateWithoutMatch2Input>
  }

  export type offsetCreateWithoutMatchInput = {
    offset_time: number
    offset_team: teamCreateNestedOneWithoutOffsetInput
  }

  export type offsetUncheckedCreateWithoutMatchInput = {
    id?: number
    offset_team_id: number
    offset_time: number
  }

  export type offsetCreateOrConnectWithoutMatchInput = {
    where: offsetWhereUniqueInput
    create: XOR<offsetCreateWithoutMatchInput, offsetUncheckedCreateWithoutMatchInput>
  }

  export type offsetCreateManyMatchInputEnvelope = {
    data: Enumerable<offsetCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type goalCreateWithoutMatchInput = {
    goal_time: number
    player: playerCreateNestedOneWithoutGoalsInput
  }

  export type goalUncheckedCreateWithoutMatchInput = {
    id?: number
    player_id: number
    goal_time: number
  }

  export type goalCreateOrConnectWithoutMatchInput = {
    where: goalWhereUniqueInput
    create: XOR<goalCreateWithoutMatchInput, goalUncheckedCreateWithoutMatchInput>
  }

  export type goalCreateManyMatchInputEnvelope = {
    data: Enumerable<goalCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type foulCreateWithoutMatchInput = {
    team_id: number
    type?: string | null
    player: playerCreateNestedOneWithoutFoulsInput
  }

  export type foulUncheckedCreateWithoutMatchInput = {
    id?: number
    team_id: number
    player_id: number
    type?: string | null
  }

  export type foulCreateOrConnectWithoutMatchInput = {
    where: foulWhereUniqueInput
    create: XOR<foulCreateWithoutMatchInput, foulUncheckedCreateWithoutMatchInput>
  }

  export type foulCreateManyMatchInputEnvelope = {
    data: Enumerable<foulCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type injuryCreateWithoutMatchInput = {
    injury_type: string
    player: playerCreateNestedOneWithoutInjurysInput
  }

  export type injuryUncheckedCreateWithoutMatchInput = {
    id?: number
    player_id: number
    injury_type: string
  }

  export type injuryCreateOrConnectWithoutMatchInput = {
    where: injuryWhereUniqueInput
    create: XOR<injuryCreateWithoutMatchInput, injuryUncheckedCreateWithoutMatchInput>
  }

  export type injuryCreateManyMatchInputEnvelope = {
    data: Enumerable<injuryCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type ballPossessionCreateWithoutMatchInput = {
    possession_time: number
    team: teamCreateNestedOneWithoutBallPossessionInput
  }

  export type ballPossessionUncheckedCreateWithoutMatchInput = {
    id?: number
    team_id: number
    possession_time: number
  }

  export type ballPossessionCreateOrConnectWithoutMatchInput = {
    where: ballPossessionWhereUniqueInput
    create: XOR<ballPossessionCreateWithoutMatchInput, ballPossessionUncheckedCreateWithoutMatchInput>
  }

  export type ballPossessionCreateManyMatchInputEnvelope = {
    data: Enumerable<ballPossessionCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type cardCreateWithoutMatchInput = {
    card_type: string
    card_time: number
    player: playerCreateNestedOneWithoutCardsInput
  }

  export type cardUncheckedCreateWithoutMatchInput = {
    id?: number
    player_id: number
    card_type: string
    card_time: number
  }

  export type cardCreateOrConnectWithoutMatchInput = {
    where: cardWhereUniqueInput
    create: XOR<cardCreateWithoutMatchInput, cardUncheckedCreateWithoutMatchInput>
  }

  export type cardCreateManyMatchInputEnvelope = {
    data: Enumerable<cardCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type switchPlayerCreateWithoutMatchInput = {
    switch_time: number
    player_out: playerCreateNestedOneWithoutSwitchPlayerOutInput
    player_in: playerCreateNestedOneWithoutSwitchPlayerInInput
  }

  export type switchPlayerUncheckedCreateWithoutMatchInput = {
    id?: number
    player_out_id: number
    player_in_id: number
    switch_time: number
  }

  export type switchPlayerCreateOrConnectWithoutMatchInput = {
    where: switchPlayerWhereUniqueInput
    create: XOR<switchPlayerCreateWithoutMatchInput, switchPlayerUncheckedCreateWithoutMatchInput>
  }

  export type switchPlayerCreateManyMatchInputEnvelope = {
    data: Enumerable<switchPlayerCreateManyMatchInput>
    skipDuplicates?: boolean
  }

  export type teamUpsertWithoutMatch1Input = {
    update: XOR<teamUpdateWithoutMatch1Input, teamUncheckedUpdateWithoutMatch1Input>
    create: XOR<teamCreateWithoutMatch1Input, teamUncheckedCreateWithoutMatch1Input>
  }

  export type teamUpdateWithoutMatch1Input = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match2?: matchUpdateManyWithoutAway_teamNestedInput
    player?: playerUpdateManyWithoutTeamNestedInput
    offset?: offsetUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutMatch1Input = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match2?: matchUncheckedUpdateManyWithoutAway_teamNestedInput
    player?: playerUncheckedUpdateManyWithoutTeamNestedInput
    offset?: offsetUncheckedUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUpsertWithoutMatch2Input = {
    update: XOR<teamUpdateWithoutMatch2Input, teamUncheckedUpdateWithoutMatch2Input>
    create: XOR<teamCreateWithoutMatch2Input, teamUncheckedCreateWithoutMatch2Input>
  }

  export type teamUpdateWithoutMatch2Input = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUpdateManyWithoutHome_teamNestedInput
    player?: playerUpdateManyWithoutTeamNestedInput
    offset?: offsetUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutMatch2Input = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUncheckedUpdateManyWithoutHome_teamNestedInput
    player?: playerUncheckedUpdateManyWithoutTeamNestedInput
    offset?: offsetUncheckedUpdateManyWithoutOffset_teamNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type offsetUpsertWithWhereUniqueWithoutMatchInput = {
    where: offsetWhereUniqueInput
    update: XOR<offsetUpdateWithoutMatchInput, offsetUncheckedUpdateWithoutMatchInput>
    create: XOR<offsetCreateWithoutMatchInput, offsetUncheckedCreateWithoutMatchInput>
  }

  export type offsetUpdateWithWhereUniqueWithoutMatchInput = {
    where: offsetWhereUniqueInput
    data: XOR<offsetUpdateWithoutMatchInput, offsetUncheckedUpdateWithoutMatchInput>
  }

  export type offsetUpdateManyWithWhereWithoutMatchInput = {
    where: offsetScalarWhereInput
    data: XOR<offsetUpdateManyMutationInput, offsetUncheckedUpdateManyWithoutOffsetInput>
  }

  export type goalUpsertWithWhereUniqueWithoutMatchInput = {
    where: goalWhereUniqueInput
    update: XOR<goalUpdateWithoutMatchInput, goalUncheckedUpdateWithoutMatchInput>
    create: XOR<goalCreateWithoutMatchInput, goalUncheckedCreateWithoutMatchInput>
  }

  export type goalUpdateWithWhereUniqueWithoutMatchInput = {
    where: goalWhereUniqueInput
    data: XOR<goalUpdateWithoutMatchInput, goalUncheckedUpdateWithoutMatchInput>
  }

  export type goalUpdateManyWithWhereWithoutMatchInput = {
    where: goalScalarWhereInput
    data: XOR<goalUpdateManyMutationInput, goalUncheckedUpdateManyWithoutGoalInput>
  }

  export type foulUpsertWithWhereUniqueWithoutMatchInput = {
    where: foulWhereUniqueInput
    update: XOR<foulUpdateWithoutMatchInput, foulUncheckedUpdateWithoutMatchInput>
    create: XOR<foulCreateWithoutMatchInput, foulUncheckedCreateWithoutMatchInput>
  }

  export type foulUpdateWithWhereUniqueWithoutMatchInput = {
    where: foulWhereUniqueInput
    data: XOR<foulUpdateWithoutMatchInput, foulUncheckedUpdateWithoutMatchInput>
  }

  export type foulUpdateManyWithWhereWithoutMatchInput = {
    where: foulScalarWhereInput
    data: XOR<foulUpdateManyMutationInput, foulUncheckedUpdateManyWithoutFoulInput>
  }

  export type injuryUpsertWithWhereUniqueWithoutMatchInput = {
    where: injuryWhereUniqueInput
    update: XOR<injuryUpdateWithoutMatchInput, injuryUncheckedUpdateWithoutMatchInput>
    create: XOR<injuryCreateWithoutMatchInput, injuryUncheckedCreateWithoutMatchInput>
  }

  export type injuryUpdateWithWhereUniqueWithoutMatchInput = {
    where: injuryWhereUniqueInput
    data: XOR<injuryUpdateWithoutMatchInput, injuryUncheckedUpdateWithoutMatchInput>
  }

  export type injuryUpdateManyWithWhereWithoutMatchInput = {
    where: injuryScalarWhereInput
    data: XOR<injuryUpdateManyMutationInput, injuryUncheckedUpdateManyWithoutInjuryInput>
  }

  export type ballPossessionUpsertWithWhereUniqueWithoutMatchInput = {
    where: ballPossessionWhereUniqueInput
    update: XOR<ballPossessionUpdateWithoutMatchInput, ballPossessionUncheckedUpdateWithoutMatchInput>
    create: XOR<ballPossessionCreateWithoutMatchInput, ballPossessionUncheckedCreateWithoutMatchInput>
  }

  export type ballPossessionUpdateWithWhereUniqueWithoutMatchInput = {
    where: ballPossessionWhereUniqueInput
    data: XOR<ballPossessionUpdateWithoutMatchInput, ballPossessionUncheckedUpdateWithoutMatchInput>
  }

  export type ballPossessionUpdateManyWithWhereWithoutMatchInput = {
    where: ballPossessionScalarWhereInput
    data: XOR<ballPossessionUpdateManyMutationInput, ballPossessionUncheckedUpdateManyWithoutBallPossessionInput>
  }

  export type cardUpsertWithWhereUniqueWithoutMatchInput = {
    where: cardWhereUniqueInput
    update: XOR<cardUpdateWithoutMatchInput, cardUncheckedUpdateWithoutMatchInput>
    create: XOR<cardCreateWithoutMatchInput, cardUncheckedCreateWithoutMatchInput>
  }

  export type cardUpdateWithWhereUniqueWithoutMatchInput = {
    where: cardWhereUniqueInput
    data: XOR<cardUpdateWithoutMatchInput, cardUncheckedUpdateWithoutMatchInput>
  }

  export type cardUpdateManyWithWhereWithoutMatchInput = {
    where: cardScalarWhereInput
    data: XOR<cardUpdateManyMutationInput, cardUncheckedUpdateManyWithoutCardInput>
  }

  export type switchPlayerUpsertWithWhereUniqueWithoutMatchInput = {
    where: switchPlayerWhereUniqueInput
    update: XOR<switchPlayerUpdateWithoutMatchInput, switchPlayerUncheckedUpdateWithoutMatchInput>
    create: XOR<switchPlayerCreateWithoutMatchInput, switchPlayerUncheckedCreateWithoutMatchInput>
  }

  export type switchPlayerUpdateWithWhereUniqueWithoutMatchInput = {
    where: switchPlayerWhereUniqueInput
    data: XOR<switchPlayerUpdateWithoutMatchInput, switchPlayerUncheckedUpdateWithoutMatchInput>
  }

  export type switchPlayerUpdateManyWithWhereWithoutMatchInput = {
    where: switchPlayerScalarWhereInput
    data: XOR<switchPlayerUpdateManyMutationInput, switchPlayerUncheckedUpdateManyWithoutSwitchPlayerInput>
  }

  export type matchCreateWithoutOffsetInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutOffsetInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutOffsetInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutOffsetInput, matchUncheckedCreateWithoutOffsetInput>
  }

  export type teamCreateWithoutOffsetInput = {
    name: string
    logo: string
    match1?: matchCreateNestedManyWithoutHome_teamInput
    match2?: matchCreateNestedManyWithoutAway_teamInput
    player?: playerCreateNestedManyWithoutTeamInput
    ballPossession?: ballPossessionCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutOffsetInput = {
    id?: number
    name: string
    logo: string
    match1?: matchUncheckedCreateNestedManyWithoutHome_teamInput
    match2?: matchUncheckedCreateNestedManyWithoutAway_teamInput
    player?: playerUncheckedCreateNestedManyWithoutTeamInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutOffsetInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutOffsetInput, teamUncheckedCreateWithoutOffsetInput>
  }

  export type matchUpsertWithoutOffsetInput = {
    update: XOR<matchUpdateWithoutOffsetInput, matchUncheckedUpdateWithoutOffsetInput>
    create: XOR<matchCreateWithoutOffsetInput, matchUncheckedCreateWithoutOffsetInput>
  }

  export type matchUpdateWithoutOffsetInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutOffsetInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type teamUpsertWithoutOffsetInput = {
    update: XOR<teamUpdateWithoutOffsetInput, teamUncheckedUpdateWithoutOffsetInput>
    create: XOR<teamCreateWithoutOffsetInput, teamUncheckedCreateWithoutOffsetInput>
  }

  export type teamUpdateWithoutOffsetInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUpdateManyWithoutHome_teamNestedInput
    match2?: matchUpdateManyWithoutAway_teamNestedInput
    player?: playerUpdateManyWithoutTeamNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutOffsetInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUncheckedUpdateManyWithoutHome_teamNestedInput
    match2?: matchUncheckedUpdateManyWithoutAway_teamNestedInput
    player?: playerUncheckedUpdateManyWithoutTeamNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type playerCreateWithoutGoalsInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutGoalsInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutGoalsInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutGoalsInput, playerUncheckedCreateWithoutGoalsInput>
  }

  export type matchCreateWithoutGoalInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutGoalInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutGoalInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutGoalInput, matchUncheckedCreateWithoutGoalInput>
  }

  export type playerUpsertWithoutGoalsInput = {
    update: XOR<playerUpdateWithoutGoalsInput, playerUncheckedUpdateWithoutGoalsInput>
    create: XOR<playerCreateWithoutGoalsInput, playerUncheckedCreateWithoutGoalsInput>
  }

  export type playerUpdateWithoutGoalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutGoalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type matchUpsertWithoutGoalInput = {
    update: XOR<matchUpdateWithoutGoalInput, matchUncheckedUpdateWithoutGoalInput>
    create: XOR<matchCreateWithoutGoalInput, matchUncheckedCreateWithoutGoalInput>
  }

  export type matchUpdateWithoutGoalInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutGoalInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type playerCreateWithoutFoulsInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutFoulsInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutFoulsInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutFoulsInput, playerUncheckedCreateWithoutFoulsInput>
  }

  export type matchCreateWithoutFoulInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutFoulInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutFoulInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutFoulInput, matchUncheckedCreateWithoutFoulInput>
  }

  export type playerUpsertWithoutFoulsInput = {
    update: XOR<playerUpdateWithoutFoulsInput, playerUncheckedUpdateWithoutFoulsInput>
    create: XOR<playerCreateWithoutFoulsInput, playerUncheckedCreateWithoutFoulsInput>
  }

  export type playerUpdateWithoutFoulsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutFoulsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type matchUpsertWithoutFoulInput = {
    update: XOR<matchUpdateWithoutFoulInput, matchUncheckedUpdateWithoutFoulInput>
    create: XOR<matchCreateWithoutFoulInput, matchUncheckedCreateWithoutFoulInput>
  }

  export type matchUpdateWithoutFoulInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutFoulInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type playerCreateWithoutInjurysInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutInjurysInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutInjurysInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutInjurysInput, playerUncheckedCreateWithoutInjurysInput>
  }

  export type matchCreateWithoutInjuryInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutInjuryInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutInjuryInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutInjuryInput, matchUncheckedCreateWithoutInjuryInput>
  }

  export type playerUpsertWithoutInjurysInput = {
    update: XOR<playerUpdateWithoutInjurysInput, playerUncheckedUpdateWithoutInjurysInput>
    create: XOR<playerCreateWithoutInjurysInput, playerUncheckedCreateWithoutInjurysInput>
  }

  export type playerUpdateWithoutInjurysInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutInjurysInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type matchUpsertWithoutInjuryInput = {
    update: XOR<matchUpdateWithoutInjuryInput, matchUncheckedUpdateWithoutInjuryInput>
    create: XOR<matchCreateWithoutInjuryInput, matchUncheckedCreateWithoutInjuryInput>
  }

  export type matchUpdateWithoutInjuryInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutInjuryInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type matchCreateWithoutBallPossessionInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutBallPossessionInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutBallPossessionInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutBallPossessionInput, matchUncheckedCreateWithoutBallPossessionInput>
  }

  export type teamCreateWithoutBallPossessionInput = {
    name: string
    logo: string
    match1?: matchCreateNestedManyWithoutHome_teamInput
    match2?: matchCreateNestedManyWithoutAway_teamInput
    player?: playerCreateNestedManyWithoutTeamInput
    offset?: offsetCreateNestedManyWithoutOffset_teamInput
  }

  export type teamUncheckedCreateWithoutBallPossessionInput = {
    id?: number
    name: string
    logo: string
    match1?: matchUncheckedCreateNestedManyWithoutHome_teamInput
    match2?: matchUncheckedCreateNestedManyWithoutAway_teamInput
    player?: playerUncheckedCreateNestedManyWithoutTeamInput
    offset?: offsetUncheckedCreateNestedManyWithoutOffset_teamInput
  }

  export type teamCreateOrConnectWithoutBallPossessionInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutBallPossessionInput, teamUncheckedCreateWithoutBallPossessionInput>
  }

  export type matchUpsertWithoutBallPossessionInput = {
    update: XOR<matchUpdateWithoutBallPossessionInput, matchUncheckedUpdateWithoutBallPossessionInput>
    create: XOR<matchCreateWithoutBallPossessionInput, matchUncheckedCreateWithoutBallPossessionInput>
  }

  export type matchUpdateWithoutBallPossessionInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutBallPossessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type teamUpsertWithoutBallPossessionInput = {
    update: XOR<teamUpdateWithoutBallPossessionInput, teamUncheckedUpdateWithoutBallPossessionInput>
    create: XOR<teamCreateWithoutBallPossessionInput, teamUncheckedCreateWithoutBallPossessionInput>
  }

  export type teamUpdateWithoutBallPossessionInput = {
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUpdateManyWithoutHome_teamNestedInput
    match2?: matchUpdateManyWithoutAway_teamNestedInput
    player?: playerUpdateManyWithoutTeamNestedInput
    offset?: offsetUpdateManyWithoutOffset_teamNestedInput
  }

  export type teamUncheckedUpdateWithoutBallPossessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    match1?: matchUncheckedUpdateManyWithoutHome_teamNestedInput
    match2?: matchUncheckedUpdateManyWithoutAway_teamNestedInput
    player?: playerUncheckedUpdateManyWithoutTeamNestedInput
    offset?: offsetUncheckedUpdateManyWithoutOffset_teamNestedInput
  }

  export type matchCreateWithoutCardInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutCardInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    switchPlayer?: switchPlayerUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutCardInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutCardInput, matchUncheckedCreateWithoutCardInput>
  }

  export type playerCreateWithoutCardsInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutCardsInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutCardsInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutCardsInput, playerUncheckedCreateWithoutCardsInput>
  }

  export type matchUpsertWithoutCardInput = {
    update: XOR<matchUpdateWithoutCardInput, matchUncheckedUpdateWithoutCardInput>
    create: XOR<matchCreateWithoutCardInput, matchUncheckedCreateWithoutCardInput>
  }

  export type matchUpdateWithoutCardInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type playerUpsertWithoutCardsInput = {
    update: XOR<playerUpdateWithoutCardsInput, playerUncheckedUpdateWithoutCardsInput>
    create: XOR<playerCreateWithoutCardsInput, playerUncheckedCreateWithoutCardsInput>
  }

  export type playerUpdateWithoutCardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type matchCreateWithoutSwitchPlayerInput = {
    home_team: teamCreateNestedOneWithoutMatch1Input
    away_team: teamCreateNestedOneWithoutMatch2Input
    offset?: offsetCreateNestedManyWithoutMatchInput
    goal?: goalCreateNestedManyWithoutMatchInput
    foul?: foulCreateNestedManyWithoutMatchInput
    injury?: injuryCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionCreateNestedManyWithoutMatchInput
    card?: cardCreateNestedManyWithoutMatchInput
  }

  export type matchUncheckedCreateWithoutSwitchPlayerInput = {
    id?: number
    homeTeam: number
    awayTeam: number
    offset?: offsetUncheckedCreateNestedManyWithoutMatchInput
    goal?: goalUncheckedCreateNestedManyWithoutMatchInput
    foul?: foulUncheckedCreateNestedManyWithoutMatchInput
    injury?: injuryUncheckedCreateNestedManyWithoutMatchInput
    ballPossession?: ballPossessionUncheckedCreateNestedManyWithoutMatchInput
    card?: cardUncheckedCreateNestedManyWithoutMatchInput
  }

  export type matchCreateOrConnectWithoutSwitchPlayerInput = {
    where: matchWhereUniqueInput
    create: XOR<matchCreateWithoutSwitchPlayerInput, matchUncheckedCreateWithoutSwitchPlayerInput>
  }

  export type playerCreateWithoutSwitchPlayerOutInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerIn?: switchPlayerCreateNestedManyWithoutPlayer_inInput
  }

  export type playerUncheckedCreateWithoutSwitchPlayerOutInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerIn?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_inInput
  }

  export type playerCreateOrConnectWithoutSwitchPlayerOutInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutSwitchPlayerOutInput, playerUncheckedCreateWithoutSwitchPlayerOutInput>
  }

  export type playerCreateWithoutSwitchPlayerInInput = {
    name: string
    numberJersey: string
    position: string
    status: Status
    goals?: goalCreateNestedManyWithoutPlayerInput
    injurys?: injuryCreateNestedManyWithoutPlayerInput
    fouls?: foulCreateNestedManyWithoutPlayerInput
    cards?: cardCreateNestedManyWithoutPlayerInput
    team: teamCreateNestedOneWithoutPlayerInput
    switchPlayerOut?: switchPlayerCreateNestedManyWithoutPlayer_outInput
  }

  export type playerUncheckedCreateWithoutSwitchPlayerInInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
    team_id: number
    goals?: goalUncheckedCreateNestedManyWithoutPlayerInput
    injurys?: injuryUncheckedCreateNestedManyWithoutPlayerInput
    fouls?: foulUncheckedCreateNestedManyWithoutPlayerInput
    cards?: cardUncheckedCreateNestedManyWithoutPlayerInput
    switchPlayerOut?: switchPlayerUncheckedCreateNestedManyWithoutPlayer_outInput
  }

  export type playerCreateOrConnectWithoutSwitchPlayerInInput = {
    where: playerWhereUniqueInput
    create: XOR<playerCreateWithoutSwitchPlayerInInput, playerUncheckedCreateWithoutSwitchPlayerInInput>
  }

  export type matchUpsertWithoutSwitchPlayerInput = {
    update: XOR<matchUpdateWithoutSwitchPlayerInput, matchUncheckedUpdateWithoutSwitchPlayerInput>
    create: XOR<matchCreateWithoutSwitchPlayerInput, matchUncheckedCreateWithoutSwitchPlayerInput>
  }

  export type matchUpdateWithoutSwitchPlayerInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutSwitchPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type playerUpsertWithoutSwitchPlayerOutInput = {
    update: XOR<playerUpdateWithoutSwitchPlayerOutInput, playerUncheckedUpdateWithoutSwitchPlayerOutInput>
    create: XOR<playerCreateWithoutSwitchPlayerOutInput, playerUncheckedCreateWithoutSwitchPlayerOutInput>
  }

  export type playerUpdateWithoutSwitchPlayerOutInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutSwitchPlayerOutInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUpsertWithoutSwitchPlayerInInput = {
    update: XOR<playerUpdateWithoutSwitchPlayerInInput, playerUncheckedUpdateWithoutSwitchPlayerInInput>
    create: XOR<playerCreateWithoutSwitchPlayerInInput, playerUncheckedCreateWithoutSwitchPlayerInInput>
  }

  export type playerUpdateWithoutSwitchPlayerInInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    team?: teamUpdateOneRequiredWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
  }

  export type playerUncheckedUpdateWithoutSwitchPlayerInInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    team_id?: IntFieldUpdateOperationsInput | number
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
  }

  export type goalCreateManyPlayerInput = {
    id?: number
    match_id: number
    goal_time: number
  }

  export type injuryCreateManyPlayerInput = {
    id?: number
    match_id: number
    injury_type: string
  }

  export type foulCreateManyPlayerInput = {
    id?: number
    match_id: number
    team_id: number
    type?: string | null
  }

  export type cardCreateManyPlayerInput = {
    id?: number
    match_id: number
    card_type: string
    card_time: number
  }

  export type switchPlayerCreateManyPlayer_outInput = {
    id?: number
    match_id: number
    player_in_id: number
    switch_time: number
  }

  export type switchPlayerCreateManyPlayer_inInput = {
    id?: number
    match_id: number
    player_out_id: number
    switch_time: number
  }

  export type goalUpdateWithoutPlayerInput = {
    goal_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutGoalNestedInput
  }

  export type goalUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalUncheckedUpdateManyWithoutGoalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type injuryUpdateWithoutPlayerInput = {
    injury_type?: StringFieldUpdateOperationsInput | string
    match?: matchUpdateOneRequiredWithoutInjuryNestedInput
  }

  export type injuryUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type injuryUncheckedUpdateManyWithoutInjurysInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type foulUpdateWithoutPlayerInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    match?: matchUpdateOneRequiredWithoutFoulNestedInput
  }

  export type foulUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foulUncheckedUpdateManyWithoutFoulsInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cardUpdateWithoutPlayerInput = {
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutCardNestedInput
  }

  export type cardUncheckedUpdateWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateManyWithoutCardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUpdateWithoutPlayer_outInput = {
    switch_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutSwitchPlayerNestedInput
    player_in?: playerUpdateOneRequiredWithoutSwitchPlayerInNestedInput
  }

  export type switchPlayerUncheckedUpdateWithoutPlayer_outInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUncheckedUpdateManyWithoutSwitchPlayerOutInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUpdateWithoutPlayer_inInput = {
    switch_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutSwitchPlayerNestedInput
    player_out?: playerUpdateOneRequiredWithoutSwitchPlayerOutNestedInput
  }

  export type switchPlayerUncheckedUpdateWithoutPlayer_inInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUncheckedUpdateManyWithoutSwitchPlayerInInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type matchCreateManyHome_teamInput = {
    id?: number
    awayTeam: number
  }

  export type matchCreateManyAway_teamInput = {
    id?: number
    homeTeam: number
  }

  export type playerCreateManyTeamInput = {
    id?: number
    name: string
    numberJersey: string
    position: string
    status: Status
  }

  export type offsetCreateManyOffset_teamInput = {
    id?: number
    match_id: number
    offset_time: number
  }

  export type ballPossessionCreateManyTeamInput = {
    id?: number
    match_id: number
    possession_time: number
  }

  export type matchUpdateWithoutHome_teamInput = {
    away_team?: teamUpdateOneRequiredWithoutMatch2NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutHome_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateManyWithoutMatch1Input = {
    id?: IntFieldUpdateOperationsInput | number
    awayTeam?: IntFieldUpdateOperationsInput | number
  }

  export type matchUpdateWithoutAway_teamInput = {
    home_team?: teamUpdateOneRequiredWithoutMatch1NestedInput
    offset?: offsetUpdateManyWithoutMatchNestedInput
    goal?: goalUpdateManyWithoutMatchNestedInput
    foul?: foulUpdateManyWithoutMatchNestedInput
    injury?: injuryUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUpdateManyWithoutMatchNestedInput
    card?: cardUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateWithoutAway_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
    offset?: offsetUncheckedUpdateManyWithoutMatchNestedInput
    goal?: goalUncheckedUpdateManyWithoutMatchNestedInput
    foul?: foulUncheckedUpdateManyWithoutMatchNestedInput
    injury?: injuryUncheckedUpdateManyWithoutMatchNestedInput
    ballPossession?: ballPossessionUncheckedUpdateManyWithoutMatchNestedInput
    card?: cardUncheckedUpdateManyWithoutMatchNestedInput
    switchPlayer?: switchPlayerUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type matchUncheckedUpdateManyWithoutMatch2Input = {
    id?: IntFieldUpdateOperationsInput | number
    homeTeam?: IntFieldUpdateOperationsInput | number
  }

  export type playerUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUpdateManyWithoutPlayerNestedInput
    fouls?: foulUpdateManyWithoutPlayerNestedInput
    cards?: cardUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
    goals?: goalUncheckedUpdateManyWithoutPlayerNestedInput
    injurys?: injuryUncheckedUpdateManyWithoutPlayerNestedInput
    fouls?: foulUncheckedUpdateManyWithoutPlayerNestedInput
    cards?: cardUncheckedUpdateManyWithoutPlayerNestedInput
    switchPlayerOut?: switchPlayerUncheckedUpdateManyWithoutPlayer_outNestedInput
    switchPlayerIn?: switchPlayerUncheckedUpdateManyWithoutPlayer_inNestedInput
  }

  export type playerUncheckedUpdateManyWithoutPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    numberJersey?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    status?: EnumStatusFieldUpdateOperationsInput | Status
  }

  export type offsetUpdateWithoutOffset_teamInput = {
    offset_time?: IntFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutOffsetNestedInput
  }

  export type offsetUncheckedUpdateWithoutOffset_teamInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type offsetUncheckedUpdateManyWithoutOffsetInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type ballPossessionUpdateWithoutTeamInput = {
    possession_time?: FloatFieldUpdateOperationsInput | number
    match?: matchUpdateOneRequiredWithoutBallPossessionNestedInput
  }

  export type ballPossessionUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type ballPossessionUncheckedUpdateManyWithoutBallPossessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    match_id?: IntFieldUpdateOperationsInput | number
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type offsetCreateManyMatchInput = {
    id?: number
    offset_team_id: number
    offset_time: number
  }

  export type goalCreateManyMatchInput = {
    id?: number
    player_id: number
    goal_time: number
  }

  export type foulCreateManyMatchInput = {
    id?: number
    team_id: number
    player_id: number
    type?: string | null
  }

  export type injuryCreateManyMatchInput = {
    id?: number
    player_id: number
    injury_type: string
  }

  export type ballPossessionCreateManyMatchInput = {
    id?: number
    team_id: number
    possession_time: number
  }

  export type cardCreateManyMatchInput = {
    id?: number
    player_id: number
    card_type: string
    card_time: number
  }

  export type switchPlayerCreateManyMatchInput = {
    id?: number
    player_out_id: number
    player_in_id: number
    switch_time: number
  }

  export type offsetUpdateWithoutMatchInput = {
    offset_time?: IntFieldUpdateOperationsInput | number
    offset_team?: teamUpdateOneRequiredWithoutOffsetNestedInput
  }

  export type offsetUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    offset_team_id?: IntFieldUpdateOperationsInput | number
    offset_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalUpdateWithoutMatchInput = {
    goal_time?: IntFieldUpdateOperationsInput | number
    player?: playerUpdateOneRequiredWithoutGoalsNestedInput
  }

  export type goalUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type goalUncheckedUpdateManyWithoutGoalInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    goal_time?: IntFieldUpdateOperationsInput | number
  }

  export type foulUpdateWithoutMatchInput = {
    team_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    player?: playerUpdateOneRequiredWithoutFoulsNestedInput
  }

  export type foulUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type foulUncheckedUpdateManyWithoutFoulInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type injuryUpdateWithoutMatchInput = {
    injury_type?: StringFieldUpdateOperationsInput | string
    player?: playerUpdateOneRequiredWithoutInjurysNestedInput
  }

  export type injuryUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type injuryUncheckedUpdateManyWithoutInjuryInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    injury_type?: StringFieldUpdateOperationsInput | string
  }

  export type ballPossessionUpdateWithoutMatchInput = {
    possession_time?: FloatFieldUpdateOperationsInput | number
    team?: teamUpdateOneRequiredWithoutBallPossessionNestedInput
  }

  export type ballPossessionUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    team_id?: IntFieldUpdateOperationsInput | number
    possession_time?: FloatFieldUpdateOperationsInput | number
  }

  export type cardUpdateWithoutMatchInput = {
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
    player?: playerUpdateOneRequiredWithoutCardsNestedInput
  }

  export type cardUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type cardUncheckedUpdateManyWithoutCardInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_id?: IntFieldUpdateOperationsInput | number
    card_type?: StringFieldUpdateOperationsInput | string
    card_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUpdateWithoutMatchInput = {
    switch_time?: IntFieldUpdateOperationsInput | number
    player_out?: playerUpdateOneRequiredWithoutSwitchPlayerOutNestedInput
    player_in?: playerUpdateOneRequiredWithoutSwitchPlayerInNestedInput
  }

  export type switchPlayerUncheckedUpdateWithoutMatchInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }

  export type switchPlayerUncheckedUpdateManyWithoutSwitchPlayerInput = {
    id?: IntFieldUpdateOperationsInput | number
    player_out_id?: IntFieldUpdateOperationsInput | number
    player_in_id?: IntFieldUpdateOperationsInput | number
    switch_time?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}